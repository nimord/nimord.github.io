<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>LFCS 10：学习简单的 Shell 脚本编程和文件系统故障排除 | ChaoS</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LFCS 10：学习简单的 Shell 脚本编程和文件系统故障排除</h1><a id="logo" href="/.">ChaoS</a><p class="description">似于混沌</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">LFCS 10：学习简单的 Shell 脚本编程和文件系统故障排除</h1><div class="post-meta">Jul 29, 2016<span> | </span><span class="category"><a href="/categories/转载/">转载</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/07/29/lfcs-10/" href="/2016/07/29/lfcs-10/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h3 id="理解终端-（Terminals）和-Shell"><a href="#理解终端-（Terminals）和-Shell" class="headerlink" title="理解终端 （Terminals）和 Shell"></a>理解终端 （Terminals）和 Shell</h3><p>首先要声明一些概念。</p>
<ul>
<li>Shell 是一个程序，它将命令传递给操作系统来执行。</li>
<li>Terminal 也是一个程序，允许最终用户使用它与 Shell 来交互。比如，下边的图片是 GNOME Terminal。</li>
</ul>
<p><em>Gnome Terminal</em></p>
<p>启动 Shell 之后，会呈现一个命令提示符 (也称为命令行) 提示我们 Shell 已经做好了准备，接受标准输入设备输入的命令，这个标准输入设备通常是键盘。</p>
<p>你可以参考该系列文章的 <a href="https://linux.cn/article-7161-1.html" target="_blank" rel="external">第一讲 如何在 Linux 上使用 GNU sed 等命令来创建、编辑和操作文件</a> 来温习一些常用的命令。</p>
<p>Linux 为提供了许多可以选用的 Shell，下面列出一些常用的：</p>
<p><strong>bash Shell</strong></p>
<p>Bash 代表 Bourne Again Shell，它是 GNU 项目默认的 Shell。它借鉴了 Korn shell (ksh) 和 C shell (csh) 中有用的特性，并同时对性能进行了提升。它同时也是 LFCS 认证中所涵盖的各发行版中默认 Shell，也是本系列教程将使用的 Shell。</p>
<p><strong>sh Shell</strong></p>
<p>Bourne SHell 是一个比较古老的 shell，多年来一直都是很多类 Unix 系统的默认 shell。</p>
<p><strong>ksh Shell</strong></p>
<p>Korn SHell (ksh shell) 也是一个 Unix shell，是贝尔实验室 （Bell Labs）的 David Korn 在 19 世纪 80 年代初的时候开发的。它兼容 Bourne shell ，并同时包含了 C shell 中的多数特性。</p>
<p>一个 shell 脚本仅仅只是一个可执行的文本文件，里边包含一条条可执行命令。</p>
<h3 id="简单的-Shell-脚本编程"><a href="#简单的-Shell-脚本编程" class="headerlink" title="简单的 Shell 脚本编程"></a>简单的 Shell 脚本编程</h3><p>如前所述，一个 shell 脚本就是一个纯文本文件，因此，可以使用自己喜欢的文本编辑器来创建和编辑。你可以考虑使用 vi/vim (参考本系列 <a href="https://linux.cn/article-7165-1.html" target="_blank" rel="external">第二讲 如何安装和使用纯文本编辑器 vi/vim</a>)，它的语法高亮让我的编辑工作非常方便。</p>
<p>输入如下命令来创建一个名为 myscript.sh 的脚本文件：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vim myscript.sh</span></span><br></pre></td></tr></table></figure>
<p>shell 脚本的第一行 (著名的<a href="https://linux.cn/article-3664-1.html" target="_blank" rel="external">释伴行</a>（shebang line）) 必须如下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash（）</span></span><br></pre></td></tr></table></figure>
<p>这条语句“告诉”操作系统需要用哪个解释器来运行这个脚本文件之后命令。</p>
<p>现在可以添加需要执行的命令了。通过注释，我们可以声明每一条命令或者整个脚本的具体含义。注意，shell 会忽略掉以井号 (#) 开始的注释语句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">echo</span> 这是关于 LFCS 认证系列的第十部分</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 今天是 $(date +%Y-%m-%d)</span><br></pre></td></tr></table></figure>
<p>编写并保存脚本之后，通过以下命令来使脚本文件成为可执行文件：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chmod 755 myscript.sh</span></span><br></pre></td></tr></table></figure>
<p>在执行脚本之前，我们需要说一下环境变量 ($PATH)，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>我们就会看到环境变量 ($PATH) 的具体内容：这是当输入命令时系统所搜索可执行程序的目录，每一项之间使用冒号 (<img src="https://dn-linuxcn.qbox.me/static/image/smiley/default/smile.gif" alt="img"> 隔开。称它为环境变量，是因为它本是就是 shell 环境的一部分 —— 这是当 shell 每次启动时 shell 及其子进程可以获取的一系列信息。</p>
<p>当我们输入一个命令并按下回车时，shell 会搜索 $PATH 变量中列出的目录并执行第一个知道的实例。请看如下例子：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201607/07/113132kzy876lll96yp4bl.png" alt="Linux Environment Variables"></p>
<p><em>环境变量</em></p>
<p>假如存在两个同名的可执行程序，一个在 /usr/local/bin，另一个在 /usr/bin，则会执行环境变量中最先列出的那个，并忽略另外一个。</p>
<p>如果我们自己编写的脚本没有放在 $PATH 变量列出目录中的任何一个，则需要输入 ./filename 来执行它。而如果存储在 $PATH 变量中的任意一个目录，我们就可以像运行其他命令一样来运行之前编写的脚本了。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># pwd</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># ./myscript.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># cp myscript.sh ../bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># cd ../bin</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># pwd</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># myscript.sh</span></span><br></pre></td></tr></table></figure>
<p><em>执行脚本</em></p>
<h4 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h4><p>无论何时，当你需要在脚本中根据某个命令的运行结果来采取相应动作时，你应该使用 if 结构来定义条件。基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> CONDITION; <span class="keyword">then</span></span><br><span class="line">    COMMANDS;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    OTHER-COMMANDS</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>其中，CONDITION 可以是如下情形的任意一项 (仅列出常用的)，并且达到以下条件时返回 true：</p>
<ul>
<li><code>[ -a file ]</code> → 指定文件存在。</li>
<li><code>[ -d file ]</code> → 指定文件存在，并且是一个目录。</li>
<li><code>[ -f file ]</code> → 指定文件存在，并且是一个普通文件。</li>
<li><code>[ -u file ]</code> → 指定文件存在，并设置了 SUID 权限位。</li>
<li><code>[ -g file ]</code> → 指定文件存在，并设置了 SGID 权限位。</li>
<li><code>[ -k file ]</code> → 指定文件存在，并设置了“黏连 (Sticky)”位。</li>
<li><code>[ -r file ]</code> → 指定文件存在，并且文件可读。</li>
<li><code>[ -s file ]</code> → 指定文件存在，并且文件不为空。</li>
<li><code>[ -w file ]</code> → 指定文件存在，并且文件可写入。</li>
<li><code>[ -x file ]</code> → 指定文件存在，并且可执行。</li>
<li><code>[ string1 = string2 ]</code> → 字符串相同。</li>
<li><code>[ string1 != string2 ]</code> → 字符串不相同。</li>
</ul>
<p>[ int1 op int2 ] 为前述列表中的一部分 (例如： -eq –&gt; int1 与 int2 相同时返回 true) ，其中比较项也可以是一个列表子项， 其中 op 为以下比较操作符。</p>
<ul>
<li><code>-eq</code> → int1 等于 int2 时返回 true。</li>
<li><code>-ne</code> → int1 不等于 int2 时返回 true。</li>
<li><code>-lt</code> → int1 小于 int2 时返回 true。</li>
<li><code>-le</code> → int1 小于或等于 int2 时返回 true。</li>
<li><code>-gt</code> → int1 大于 int2 时返回 true。</li>
<li><code>-ge</code> → int1 大于或等于 int2 时返回 true。</li>
</ul>
<h4 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h4><p>循环语句可以在某个条件下重复执行某个命令。基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> SEQUENCE; <span class="keyword">do</span></span><br><span class="line">        COMMANDS;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>其中，item 为每次执行 COMMANDS 时，在 SEQUENCE 中匹配到的值。</p>
<h4 id="While-循环语句"><a href="#While-循环语句" class="headerlink" title="While 循环语句"></a>While 循环语句</h4><p>该循环结构会一直执行重复的命令，直到控制命令（EVALUATION_COMMAND）执行的退出状态值等于 0 时 (即执行成功) 停止。基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> EVALUATION_COMMAND; <span class="keyword">do</span></span><br><span class="line">        EXECUTE_COMMANDS;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>其中，EVALUATION_COMMAND 可以是任何能够返回成功 (0) 或失败 (0 以外的值) 的退出状态值的命令，EXECUTE_COMMANDS 则可以是任何的程序、脚本或者 shell 结构体，包括其他的嵌套循环。</p>
<h4 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h4><p>我们会通过以下例子来演示 if 条件语句和 for 循环语句。</p>
<p><strong>在基于 systemd 的发行版中探测某个服务是否在运行</strong></p>
<p>先建立一个文件，列出我们想要想要查看的服务名。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat myservices.txt</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">sshd</span></span><br><span class="line">mariadb</span><br><span class="line">httpd</span><br><span class="line">crond</span><br><span class="line">firewalld</span><br></pre></td></tr></table></figure>
<p><em>使用脚本监控 Linux 服务</em></p>
<p>我们编写的脚本看起来应该是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># This script iterates over a list of services and</span></span><br><span class="line"><span class="comment"># is used to determine whether they are running or not.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> $(cat myservices.txt); <span class="keyword">do</span></span><br><span class="line">        systemctl status <span class="variable">$service</span> | grep --quiet <span class="string">"running"</span></span><br><span class="line">        <span class="keyword">if</span> [ $? <span class="_">-eq</span> 0 ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$service</span> <span class="string">"is [ACTIVE]"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="variable">$service</span> <span class="string">"is [INACTIVE or NOT INSTALLED]"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><em>Linux 服务监控脚本</em></p>
<p><strong>我们来解释一下这个脚本的工作流程</strong></p>
<p>1). for 循环每次读取 myservices.txt 文件中的一项记录，每一项纪录表示一个服务的通用变量名。各项记录组成如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat myservices.txt</span></span><br></pre></td></tr></table></figure>
<p>2). 以上命令由圆括号括着，并在前面添加美元符，表示它需要从 myservices.txt 的记录列表中取值并作为变量传递给 for 循环。</p>
<p>3). 对于记录列表中的每一项纪录 (即每一项纪录的服务变量)，都会执行以下动作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># systemctl status $service | grep --quiet <span class="string">"running"</span></span></span><br></pre></td></tr></table></figure>
<p>此时，需要在每个通用变量名 (即每一项纪录的服务变量) 的前面添加美元符，以表明它是作为变量来传递的。其输出则通过管道符传给 grep。</p>
<p>其中，-quiet 选项用于阻止 grep 命令将发现的 “running” 的行回显到屏幕。当 grep 捕获到 “running” 时，则会返回一个退出状态码 “0” (在 if 结构体表示为 $?)，由此确认某个服务正在运行中。</p>
<p>如果退出状态码是非零值 (即 systemctl status $service 命令中的回显中没有出现 “running”)，则表明某个服务未运行。</p>
<p><em>服务监控脚本</em></p>
<p>我们可以增加一步，在开始循环之前，先确认 myservices.txt 是否存在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># This script iterates over a list of services and</span></span><br><span class="line"><span class="comment"># is used to determine whether they are running or not.</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="_">-f</span> myservices.txt ]; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> service <span class="keyword">in</span> $(cat myservices.txt); <span class="keyword">do</span></span><br><span class="line">                systemctl status <span class="variable">$service</span> | grep --quiet <span class="string">"running"</span></span><br><span class="line">                <span class="keyword">if</span> [ $? <span class="_">-eq</span> 0 ]; <span class="keyword">then</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="variable">$service</span> <span class="string">"is [ACTIVE]"</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">echo</span> <span class="variable">$service</span> <span class="string">"is [INACTIVE or NOT INSTALLED]"</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"myservices.txt is missing"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><strong>Ping 一系列网络或者 Internet 主机名以获取应答数据</strong></p>
<p>你可能想把自己维护的主机写入一个文本文件，并使用脚本探测它们是否能够 ping 得通 (脚本中的 myhosts 可以随意替换为你想要的名称)。</p>
<p>shell 的内置 read 命令将告诉 while 循环一行行的读取 myhosts，并将读取的每行内容传给 host 变量，随后 host 变量传递给 ping 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># This script is used to demonstrate the use of a while loop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> host; <span class="keyword">do</span></span><br><span class="line">        ping -c 2 <span class="variable">$host</span></span><br><span class="line"><span class="keyword">done</span> &lt; myhosts</span><br></pre></td></tr></table></figure>
<p><em>使用脚本 Ping 服务器</em></p>
<p>扩展阅读:</p>
<ul>
<li><a href="http://www.tecmint.com/learning-shell-scripting-language-a-guide-from-newbies-to-system-administrator/" target="_blank" rel="external">Learn Shell Scripting: A Guide from Newbies to System Administrator</a></li>
<li><a href="http://www.tecmint.com/basic-shell-programming-part-ii/" target="_blank" rel="external">5 Shell Scripts to Learn Shell Programming</a></li>
</ul>
<h3 id="文件系统排错"><a href="#文件系统排错" class="headerlink" title="文件系统排错"></a>文件系统排错</h3><p>尽管 Linux 是一个很稳定的操作系统，但仍然会因为某些原因出现崩溃时 (比如因为断电等)，正好你有一个 (或者更多个) 文件系统未能正确卸载，Linux 重启的时候就会自动检测其中可能发生的错误。</p>
<p>此外，每次系统正常启动的时候，都会在文件系统挂载之前校验它们的完整度。而这些全部都依赖于 fsck 工具 (文件系统校验（file system check）)。</p>
<p>如果对 fsck 进行设定，它除了校验文件系统的完整性之外，还可以尝试修复错误。fsck 能否成功修复错误，取决于文件系统的损伤程度；如果可以修复，被损坏部分的文件会恢复到位于每个文件系统根目录的 lost+found。</p>
<p>最后但同样重要的是，我们必须注意，如果拔掉系统正在写入数据的 USB 设备同样会发生错误，甚至可能发生硬件损坏。</p>
<p>fsck 的基本用如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># fsck [options] filesystem</span></span><br></pre></td></tr></table></figure>
<p><strong>检查文件系统错误并尝试自动修复</strong></p>
<p>想要使用 fsck 检查文件系统，我们需要首先卸载文件系统。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount | grep sdg1</span></span><br><span class="line"><span class="meta"># umount /mnt</span></span><br><span class="line"><span class="meta"># fsck -y /dev/sdg1</span></span><br></pre></td></tr></table></figure>
<p><em>检查文件系统错误</em></p>
<p>除了 -y 选项，我们也可以使用 -a 选项来自动修复文件系统错误，而不必做出交互式应答，并在文件系统看起来 “干净” 卸载的情况下强制校验。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># fsck -af /dev/sdg1</span></span><br></pre></td></tr></table></figure>
<p>如果只是要找出什么地方发生了错误 (不用在检测到错误的时候修复)，我们可以使用 -n 选项，这样只会将文件系统错误输出到标准输出设备上。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># fsck -n /dev/sdg1</span></span><br></pre></td></tr></table></figure>
<p>根据 fsck 输出的错误信息，我们可以知道是否可以自己修复或者需要将问题提交给工程师团队来做详细的硬件校验。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="nimord.github.io/2016/07/29/lfcs-10/" data-id="cix2odymn000uuwawnpnh2ysn" class="article-share-link">分享到</a><div class="tags"><a href="/tags/lfcs/">lfcs</a></div><div class="post-nav"><a href="/2016/07/29/lfcs-11/" class="pre">LFCS 11：如何使用命令 vgcreate、lvcreate 和 lvextend 管理和创建 LVM</a><a href="/2016/07/29/lfcs-09/" class="next">LFCS 09：使用 Yum/RPM/Apt/Dpkg/Aptitude 进行 Linux 软件包管理</a></div><div id="disqus_thread"><script>var disqus_shortname = 'qiankun';
var disqus_identifier = '2016/07/29/lfcs-10/';
var disqus_title = 'LFCS 10：学习简单的 Shell 脚本编程和文件系统故障排除';
var disqus_url = 'nimord.github.io/2016/07/29/lfcs-10/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//qiankun.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/转载/">转载</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/essay/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/lfcs/" style="font-size: 15px;">lfcs</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-12/">LFCS 12：如何使用 Linux 的帮助文档和工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-11/">LFCS 11：如何使用命令 vgcreate、lvcreate 和 lvextend 管理和创建 LVM</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-10/">LFCS 10：学习简单的 Shell 脚本编程和文件系统故障排除</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-09/">LFCS 09：使用 Yum/RPM/Apt/Dpkg/Aptitude 进行 Linux 软件包管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-08/">LFCS 08：管理用户和用户组、文件权限和属性以及启用账户 sudo 访问权限</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-07/">LFCS 07：通过 SysVinit、Systemd 和 Upstart 管理系统自启动进程和服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-06/">LFCS 06：组装分区为RAID设备——创建和管理系统备份</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-05/">LFCS 05：如何在 Linux 中挂载/卸载本地文件系统和网络文件系统（Samba 和 NFS）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-04/">LFCS 04：对存储设备分区、格式化文件系统和配置交换分区</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/lfcs-03/">LFCS 03：归档/压缩文件及目录、设置文件属性和搜索文件</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//qiankun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">ChaoS.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>