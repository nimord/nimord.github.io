<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[lfcs-12]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-12/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[lfcs-11]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-11/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[lfcs-10]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-10/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[lfcs-09]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-09/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[lfcs-08]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-08/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[lfcs-07]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-07/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 06：组装分区为RAID设备——创建和管理系统备份]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-06/</url>
      <content type="html"><![CDATA[<h3 id="了解RAID"><a href="#了解RAID" class="headerlink" title="了解RAID"></a>了解RAID</h3><p>这种被称为独立磁盘冗余阵列（Redundant Array of Independent Disks）(RAID)的技术是将多个硬盘组合成一个单独逻辑单元的存储解决方案，它提供了数据冗余功能并且改善硬盘的读写操作性能。</p>
<p>然而，实际的容错和磁盘 I/O 性能硬盘取决于如何将多个硬盘组装成磁盘阵列。根据可用的设备和容错/性能的需求，RAID 被分为不同的级别，你可以参考 RAID 系列文章以获得每个 RAID 级别更详细的解释。</p>
<ul>
<li><a href="https://linux.cn/article-6085-1.html" target="_blank" rel="external">在 Linux 下使用 RAID（一）：介绍 RAID 的级别和概念</a></li>
</ul>
<p>我们选择用于创建、组装、管理、监视软件 RAID 的工具，叫做 mdadm (multiple disk admin 的简写）。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Debian</span> <span class="comment">及衍生版</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">#</span> <span class="comment">aptitude</span> <span class="comment">update</span> <span class="comment">&amp;&amp;</span> <span class="comment">aptitude</span> <span class="comment">install</span> <span class="comment">mdadm</span></span><br></pre></td></tr></table></figure>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">Red</span> <span class="comment">Hat</span> <span class="comment">和基于</span> <span class="comment">CentOS</span> <span class="comment">的系统</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">#</span> <span class="comment">yum</span> <span class="comment">update</span> <span class="comment">&amp;&amp;</span> <span class="comment">yum</span> <span class="comment">install</span> <span class="comment">mdadm</span></span><br></pre></td></tr></table></figure>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">openSUSE</span> <span class="comment">上</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">#</span> <span class="comment">zypper</span> <span class="comment">refresh</span> <span class="comment">&amp;&amp;</span> <span class="comment">zypper</span> <span class="comment">install</span> <span class="comment">mdadm</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h4 id="将分区组装成-RAID-设备"><a href="#将分区组装成-RAID-设备" class="headerlink" title="将分区组装成 RAID 设备"></a>将分区组装成 RAID 设备</h4><p>组装已有分区作为 RAID 设备的过程由以下步骤组成。</p>
<p><strong>1. 使用 mdadm 创建阵列</strong></p>
<p>如果先前其中一个分区已经格式化，或者作为了另一个 RAID 阵列的一部分，你会被提示以确认创建一个新的阵列。假设你已经采取了必要的预防措施以避免丢失重要数据，那么可以安全地输入 Y 并且按下回车。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="comment">/dev/md0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">level=stripe</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">raid</span><span class="literal">-</span><span class="comment">devices=2</span> <span class="comment">/dev/sdb1</span> <span class="comment">/dev/sdc1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222344q1889bbk5n869592.png" alt="创建 RAID 阵列"></p>
<p><em>创建 RAID 阵列</em></p>
<p><strong>2. 检查阵列的创建状态</strong></p>
<p>在创建了 RAID 阵列之后，你可以检查使用以下命令检查阵列的状态。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat <span class="regexp">/proc/m</span>dstator# mdadm --detail <span class="regexp">/dev/m</span>d0    [More detailed summary]</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222348pxren45x9z57pzbu.png" alt="检查 RAID 阵列的状态"></p>
<p><em>检查 RAID 阵列的状态</em></p>
<p><strong>3. 格式化 RAID 设备</strong></p>
<p>如本系列<a href="https://linux.cn/article-7187-1.html" target="_blank" rel="external">第四讲</a>所介绍的，按照你的需求/要求采用某种文件系统格式化你的设备。</p>
<p><strong>4. 监控 RAID 阵列服务</strong></p>
<p>让监控服务时刻监视你的 RAID 阵列。把<code># mdadm --detail --scan</code>命令输出结果添加到 <code>/etc/mdadm/mdadm.conf</code>(Debian及其衍生版)或者<code>/etc/mdadm.conf</code>(Cent0S/openSUSE)，如下。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">detail</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">scan</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222354jdhnm2wyasnzhmv3.png" alt="监控 RAID 阵列"></p>
<p><em>监控 RAID 阵列</em></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mdadm --assemble --scan     [Assemble the array]</span></span><br></pre></td></tr></table></figure>
<p>为了确保服务能够开机启动，需要以 root 权限运行以下命令。</p>
<p><strong>Debian 及其衍生版</strong></p>
<p>Debian 及其衍生版能够通过下面步骤使服务默认开机启动：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">update</span>-rc.<span class="keyword">d</span> mdadm defaults</span><br></pre></td></tr></table></figure>
<p>在 <code>/etc/default/mdadm</code> 文件中添加下面这一行</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AUTOSTART</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>CentOS 和 openSUSE(systemd-based)</strong></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># systemctl start mdmonitor# systemctl enable mdmonitor</span></span><br></pre></td></tr></table></figure>
<p><strong>CentOS 和 openSUSE(SysVinit-based)</strong></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># service mdmonitor start# chkconfig mdmonitor on</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 检查RAID磁盘故障</strong></p>
<p>在支持冗余的的 RAID 级别中，在需要时会替换故障的驱动器。当磁盘阵列中的设备出现故障时，仅当存在我们第一次创建阵列时预留的备用设备时，磁盘阵列会将自动启动重建。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222400usjj5mzsxvwvql2n.png" alt="检查 RAID 故障磁盘"></p>
<p><em>检查 RAID 故障磁盘</em></p>
<p>否则，我们需要手动将一个额外的物理驱动器插入到我们的系统，并且运行。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdadm <span class="regexp">/dev/m</span>d0 --add <span class="regexp">/dev/</span>sdX1</span><br></pre></td></tr></table></figure>
<p>/dev/md0 是出现了问题的阵列，而 /dev/sdx1 是新添加的设备。</p>
<p><strong>6. 拆解一个工作阵列</strong></p>
<p>如果你需要使用工作阵列的设备创建一个新的阵列，你可能不得不去拆解已有工作阵列——(可选步骤)</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mdadm --stop /dev/md0                 #  Stop the array# mdadm --remove /dev/md0             # Remove the RAID device# mdadm --zero-superblock /dev/sdX1     # Overwrite the existing md superblock with zeroes</span></span><br></pre></td></tr></table></figure>
<p><strong>7. 设置邮件通知</strong></p>
<p>你可以配置一个用于发送通知的有效邮件地址或者系统账号(确保在 mdadm.conf 文件中有下面这一行)。——(可选步骤)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MAILADDR</span> root</span><br></pre></td></tr></table></figure>
<p>在这种情况下，来自 RAID 后台监控程序所有的通知将会发送到你的本地 root 账号的邮件箱中。其中一个类似的通知如下。</p>
<p>说明：此次通知事件和第5步中的例子相关。此处一个设备被标志为错误，并且一个空闲的设备自动地被 mdadm 加入到阵列。我们用完了所有“健康的”空闲设备，因此我们得到了通知。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222403ao1rbkmzdh5iplm9.png" alt="RAID 监控通知"></p>
<p><em>RAID 监控通知</em></p>
<h4 id="了解-RAID-级别"><a href="#了解-RAID-级别" class="headerlink" title="了解 RAID 级别"></a>了解 RAID 级别</h4><p><strong>RAID 0</strong></p>
<p>阵列总大小是最小分区大小的 n 倍，n 是阵列中独立磁盘的个数(你至少需要两个驱动器/磁盘)。运行下面命令，使用 /dev/sdb1 和 /dev/sdc1 分区组装一个 RAID 0 阵列。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="comment">/dev/md0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">level=stripe</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">raid</span><span class="literal">-</span><span class="comment">devices=2</span> <span class="comment">/dev/sdb1</span> <span class="comment">/dev/sdc1</span></span><br></pre></td></tr></table></figure>
<p>常见用途：用于支持性能比容错更重要的实时应用程序的设置</p>
<p><strong>RAID 1 (又名镜像)</strong></p>
<p>阵列总大小等于最小分区大小(你至少需要两个驱动器/磁盘)。运行下面命令，使用 /dev/sdb1 和 /dev/sdc1 分区组装一个 RAID 1 阵列。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="comment">/dev/md0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">level=1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">raid</span><span class="literal">-</span><span class="comment">devices=2</span> <span class="comment">/dev/sdb1</span> <span class="comment">/dev/sdc1</span></span><br></pre></td></tr></table></figure>
<p>常见用途：操作系统的安装或者重要的子文件夹，例如 /home</p>
<p><strong>RAID 5 (又名奇偶校验码盘)</strong></p>
<p>阵列总大小将是最小分区大小的 (n-1) 倍。所减少的大小用于奇偶校验(冗余)计算(你至少需要3个驱动器/磁盘)。</p>
<p>说明：你可以指定一个空闲设备 (/dev/sde1) 替换问题出现时的故障部分(分区)。运行下面命令，使用 /dev/sdb1, /dev/sdc1, /dev/sdd1，/dev/sde1 组装一个 RAID 5 阵列，其中 /dev/sde1 作为空闲分区。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="comment">/dev/md0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">level=5</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">raid</span><span class="literal">-</span><span class="comment">devices=3</span> <span class="comment">/dev/sdb1</span> <span class="comment">/dev/sdc1</span> <span class="comment">/dev/sdd1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">spare</span><span class="literal">-</span><span class="comment">devices=1</span> <span class="comment">/dev/sde1</span></span><br></pre></td></tr></table></figure>
<p>常见用途：Web 和文件服务</p>
<p><strong>RAID 6 (又名双重奇偶校验码盘)</strong></p>
<p>阵列总大小为(n<em>s)-2</em>s，其中n为阵列中独立磁盘的个数，s为最小磁盘大小。</p>
<p>说明：你可以指定一个空闲分区(在这个例子为 /dev/sdf1)替换问题出现时的故障部分(分区)。</p>
<p>运行下面命令，使用 /dev/sdb1, /dev/sdc1, /dev/sdd1, /dev/sde1 和 /dev/sdf1 组装 RAID 6 阵列，其中 /dev/sdf1 作为空闲分区。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mdadm --create --verbose <span class="regexp">/dev/m</span>d0 --level=<span class="number">6</span> --raid-devices=<span class="number">4</span> <span class="regexp">/dev/</span>sdb1 <span class="regexp">/dev/</span>sdc1 <span class="regexp">/dev/</span>sdd1 <span class="regexp">/dev/</span>sde --spare-devices=<span class="number">1</span> <span class="regexp">/dev/</span>sdf1</span><br></pre></td></tr></table></figure>
<p>常见用途：大容量、高可用性要求的文件服务器和备份服务器。</p>
<p><strong>RAID 1+0 (又名镜像条带)</strong></p>
<p>因为 RAID 1+0 是 RAID 0 和 RAID 1 的组合，所以阵列总大小是基于两者的公式计算的。首先，计算每一个镜像的大小，然后再计算条带的大小。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">mdadm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">verbose</span> <span class="comment">/dev/md0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">level=10</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">raid</span><span class="literal">-</span><span class="comment">devices=4</span> <span class="comment">/dev/sd</span><span class="title">[</span><span class="comment">b</span><span class="literal">-</span><span class="comment">e</span><span class="title">]</span><span class="comment">1</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">spare</span><span class="literal">-</span><span class="comment">devices=1</span> <span class="comment">/dev/sdf1</span></span><br></pre></td></tr></table></figure>
<p>常见用途：需要快速 IO 操作的数据库和应用服务器</p>
<h4 id="创建和管理系统备份"><a href="#创建和管理系统备份" class="headerlink" title="创建和管理系统备份"></a>创建和管理系统备份</h4><p>记住， RAID 其所有的价值不是在于备份的替换者！在黑板上写上1000次，如果你需要的话，但无论何时一定要记住它。在我们开始前，我们必须注意的是，没有一个放之四海皆准的针对所有系统备份的解决方案，但这里有一些东西，是你在规划一个备份策略时需要考虑的。</p>
<ul>
<li>你的系统将用于什么？(桌面或者服务器？如果系统是应用于后者，那么最重要的服务是什么？哪个配置是痛点？)</li>
<li>你每隔多久备份你的系统？</li>
<li>你需要备份的数据是什么(比如文件/文件夹/数据库转储)？你还可以考虑是否需要备份大型文件(比如音频和视频文件)。</li>
<li>这些备份将会存储在哪里(物理位置和媒体)？</li>
</ul>
<p><strong>备份你的数据</strong></p>
<p>方法1：使用 dd 命令备份整个磁盘。你可以在任意时间点通过创建一个准确的镜像来备份一整个硬盘或者是分区。注意当设备是离线时，这种方法效果最好，也就是说它没有被挂载并且没有任何进程的 I/O 操作访问它。</p>
<p>这种备份方法的缺点是镜像将具有和磁盘或分区一样的大小，即使实际数据占用的是一个很小的比例。比如，如果你想要为只使用了10%的20GB的分区创建镜像，那么镜像文件将仍旧是20GB。换句话来讲，它不仅包含了备份的实际数据，而且也包含了整个分区。如果你想完整备份你的设备，那么你可以考虑使用这个方法。</p>
<p><strong>从现有的设备创建一个镜像文件</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>sda of=<span class="regexp">/system_images/</span>sda.img或者--------------------- 可选地，你可以压缩镜像文件 -------------------# dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>sda | gzip -c &gt; <span class="regexp">/system_images/</span>sda.img.gz</span><br></pre></td></tr></table></figure>
<p><strong>从镜像文件恢复备份</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd <span class="keyword">if</span>=<span class="regexp">/system_images/</span>sda.img of=<span class="regexp">/dev/</span>sda或者--------------------- 根据你创建镜像文件时的选择(译者注:比如压缩) ----------------# gzip -dc <span class="regexp">/system_images/</span>sda.img.gz | dd of=<span class="regexp">/dev/</span>sda</span><br></pre></td></tr></table></figure>
<p>方法2：使用 tar 命令备份确定的文件/文件夹——已经在本系列<a href="https://linux.cn/article-7171-1.html" target="_blank" rel="external">第三讲</a>中讲了。如果你想要备份指定的文件/文件夹(配置文件，用户主目录等等)，你可以使用这种方法。</p>
<p>方法3：使用 rsync 命令同步文件。rsync 是一种多功能远程（和本地）文件复制工具。如果你想要从网络设备备份或同步文件，rsync 是一种选择。</p>
<p>无论是你是正在同步两个本地文件夹还是本地 &lt; — &gt; 挂载在本地文件系统的远程文件夹，其基本语法是一样的。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># rsync -av source_directory destination_directory</span></span><br></pre></td></tr></table></figure>
<p>在这里，-a 递归遍历子目录(如果它们存在的话)，维持符号链接、时间戳、权限以及原本的属主/属组，-v 显示详细过程。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222405x8a94kkqyffay9sp.png" alt="rsync 同步文件"></p>
<p><em>rsync 同步文件</em></p>
<p>除此之外，如果你想增加在网络上传输数据的安全性，你可以通过 ssh 协议使用 rsync。</p>
<p><strong>通过 ssh 同步本地到远程文件夹</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsync -avzhe ssh backups root<span class="doctag">@remote</span>_host:/remote_directory/</span></span><br></pre></td></tr></table></figure>
<p>这个示例，本地主机上的 backups 文件夹将与远程主机上的 /root/remote_directory 的内容同步。</p>
<p>在这里，-h 选项以易读的格式显示文件的大小，-e 标志用于表示一个 ssh 连接。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/15/222410w0r0bcclcgtgc3cf.png" alt="rsync 同步远程文件"></p>
<p><em>rsync 同步远程文件</em></p>
<p><strong>通过ssh同步远程到本地文件夹</strong></p>
<p>在这种情况下，交换前面示例中的 source 和 destination 文件夹。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsync -avzhe ssh root<span class="doctag">@remote</span>_host:/remote_directory/ backups</span></span><br></pre></td></tr></table></figure>
<p>请注意这些只是 rsync 用法的三个示例而已(你可能遇到的最常见的情形)。对于更多有关 rsync 命令的示例和用法 ，你可以查看下面的文章。</p>
<ul>
<li><a href="http://www.tecmint.com/rsync-local-remote-file-synchronization-commands/" target="_blank" rel="external">在 Linux 下同步文件的10个 rsync命令</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 05：如何在 Linux 中挂载/卸载本地文件系统和网络文件系统（Samba 和 NFS）]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-05/</url>
      <content type="html"><![CDATA[<h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><p>在个硬盘分好区之后，Linux 需要通过某些方式对硬盘分区上的数据进行访问。Linux 并不会像 DOS 或者 Windows 那样给每个硬盘分区分配一个字母来作为盘符，而是将硬盘分区挂载到统一的目录树上的挂载点。</p>
<p>挂载点是一个目录，挂载是一种访问分区上文件系统的方法，挂载文件系统实际上是将一个确切的文件系统（比如一个分区）和目录树中指定的目录联系起来的过程。</p>
<p>换句话说，管理存储设备的第一步就是把设备关联到文件系统树。要完成这一步，通常可以这样：用 mount 命令来进行临时挂载（用完的时候，使用 umount 命令来卸载），或者通过编辑 /etc/fstab 文件之后重启系统来永久性挂载，这样每次开机都会进行挂载。</p>
<p>不带任何选项的 mount 命令，可以显示当前已挂载的文件系统。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083734afzlpfl896fopcqr.png" alt="检查已挂载的文件系统"></p>
<p><em>检查已挂载的文件系统</em></p>
<p>另外，mount 命令通常用来挂载文件系统。其基本语法如下：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t <span class="built_in">type</span> device <span class="built_in">dir</span> -o options</span><br></pre></td></tr></table></figure>
<p>该命令会指引内核将在设备上找到的文件系统（如已格式化为指定类型的文件系统）挂载到指定目录。像这样的形式，mount 命令不会再到 /etc/fstab 文件中进行确认。</p>
<p>除非像下面，挂载指定的目录或者设备：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount /dir -o <span class="keyword">options</span>或# mount device -o <span class="keyword">options</span></span><br></pre></td></tr></table></figure>
<p>mount 命令会尝试寻找挂载点，如果找不到就会查找设备（上述两种情况下，mount 命令会在 /etc/fstab 查找相应的设备或挂载点），最后尝试完成挂载操作（这个通常可以成功执行，除非你的挂载点或者设备正在使用中，或者你调用 mount 命令的时候没有 root 权限）。</p>
<p>你可以看到，mount 命令的每行输出都是如下格式：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">device</span> on directory <span class="keyword">type</span> (options)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/debian-home on /home <span class="keyword">type</span> ext4 (rw,relatime,user_xattr,barrier=1,data=ordered)</span><br></pre></td></tr></table></figure>
<p>读作：</p>
<p>设备 dev/mapper/debian-home 挂载在 /home 下，它被格式化为 ext4，并且有以下挂载选项： rw，relatime，user_xattr，barrier=1，data=ordered。</p>
<p><strong>mount 命令选项</strong></p>
<p>下面列出 mount 命令的常用选项</p>
<ul>
<li>async：允许在将要挂载的文件系统上进行异步 I/O 操作</li>
<li>auto：标示该文件系统通过 mount -a 命令挂载，与 noauto 相反。</li>
<li>defaults：该选项相当于 <code>async,auto,dev,exec,nouser,rw,suid</code> 的组合。注意，多个选项必须由逗号隔开并且中间没有空格。倘若你不小心在两个选项中间输入了一个空格，mount 命令会把后边的字符解释为另一个参数。</li>
<li>loop：将镜像文件（如 .iso 文件）挂载为 loop 设备。该选项可以用来模拟显示光盘中的文件内容。</li>
<li>noexec：阻止该文件系统中可执行文件的执行。与 exec 选项相反。</li>
<li>nouser：阻止任何用户（除 root 用户外） 挂载或卸载文件系统。与 user 选项相反。</li>
<li>remount：重新挂载文件系统。</li>
<li>ro：只读模式挂载。</li>
<li>rw：读写模式挂载。</li>
<li>relatime：只要访问时间早于修改时间，就更新文件的的访问时间。</li>
<li>user_xattr：允许用户设置和移除可扩展文件系统属性。</li>
</ul>
<p><strong>以 ro 和 noexec 模式挂载设备</strong></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t ext4 /dev/sdg1 /mnt -o ro,noexec</span></span><br></pre></td></tr></table></figure>
<p>在本例中，我们可以看到，在挂载点 /mnt 中尝试写入文件或者运行可执行文件都会显示相应的错误信息。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># touch <span class="regexp">/mnt/my</span><span class="keyword">file</span># <span class="regexp">/mnt/</span>bin<span class="regexp">/echo “Hi there”</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083734uzm5q55ewemrsm5q.png" alt="可读写模式挂载设备"></p>
<p><em>可读写模式挂载设备</em></p>
<p><strong>以默认模式挂载设备</strong></p>
<p>以下场景，我们在重新挂载设备的挂载点中，像上例一样尝试你写入文件和运行可执行文件。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mount -t ext4 /dev/sdg1 /mnt -o defaults</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083735vrwasmt1pwrkvr1t.png" alt="挂载设备"></p>
<p><em>挂载设备</em></p>
<p>在这个例子中，我们发现写入文件和命令都完美执行了。</p>
<h3 id="卸载设备"><a href="#卸载设备" class="headerlink" title="卸载设备"></a>卸载设备</h3><p>使用 umount 命令卸载设备，意味着将所有的“在使用”数据全部写入到文件系统，然后可以安全移除文件系统。请注意，倘若你移除一个没有事先正确卸载的设备，就会有造成设备损坏和数据丢失的风险。</p>
<p>也就是说，你必须“离开”设备的块设备描述符或者挂载点，才能卸载设备。换言之，你的当前工作目录不能是需要卸载设备的挂载点。否则，系统将返回设备繁忙的提示信息。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083735la66phyyjhopkojp.png" alt="卸载设备"></p>
<p><em>卸载设备</em></p>
<p>离开需卸载设备的挂载点最简单的方法就是，运行不带任何选项的 cd 命令，这样会回到当前用户的家目录。</p>
<h3 id="挂载常见的网络文件系统"><a href="#挂载常见的网络文件系统" class="headerlink" title="挂载常见的网络文件系统"></a>挂载常见的网络文件系统</h3><p>最常用的两种网络文件系统是 SMB（服务器消息块Server Message Block）和 NFS（网络文件系统Network File System）。如果你只向类 Unix 客户端提供共享，用 NFS 就可以了，如果是向 Windows 和其他类 Unix 客户端提供共享服务，就需要用到 Samba 了。</p>
<p>扩展阅读</p>
<ul>
<li><a href="http://www.tecmint.com/setup-samba-server-using-tdbsam-backend-on-rhel-centos-6-3-5-8-and-fedora-17-12/" target="_blank" rel="external">Setup Samba Server in RHEL/CentOS and Fedora</a></li>
<li><a href="http://www.tecmint.com/how-to-setup-nfs-server-in-linux/" target="_blank" rel="external">Setting up NFS (Network File System) on RHEL/CentOS/Fedora and Debian/Ubuntu</a></li>
</ul>
<p>下面的例子中，假设 Samba 和 NFS 已经在地址为 192.168.0.10 的服务器上架设好了（请注意，架设 NFS 服务器也是 LFCS 考试中需要考核的能力，我们会在后边中提到）。</p>
<h4 id="在-Linux-中挂载-Samba-共享"><a href="#在-Linux-中挂载-Samba-共享" class="headerlink" title="在 Linux 中挂载 Samba 共享"></a>在 Linux 中挂载 Samba 共享</h4><p>第一步：在 Red Hat 以 Debian 系发行版中安装 samba-client、samba-common 和 cifs-utils 软件包，如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum update &amp;&amp; yum install samba-client samba-<span class="meta">common</span> cifs-utils# aptitude update &amp;&amp; aptitude install samba-client samba-<span class="meta">common</span> cifs-utils</span><br></pre></td></tr></table></figure>
<p>然后运行下列命令，查看服务器上可用的 Samba 共享。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">smbclient</span> <span class="selector-tag">-L</span> 192<span class="selector-class">.168</span><span class="selector-class">.0</span><span class="selector-class">.10</span></span><br></pre></td></tr></table></figure>
<p>并输入远程机器上 root 账户的密码。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083735n0tuv0bpr8snpt8b.png" alt="挂载 Samba 共享"></p>
<p><em>挂载 Samba 共享</em></p>
<p>上图中，已经对可以挂载到我们本地系统上的共享进行高亮显示。你只需要与一个远程服务器上的合法用户名及密码就可以访问共享了。</p>
<p>第二步：当挂载有密码保护的网络文件系统时候，将你的访问凭证写入到 /etc/fstab 文件中并非明智的选择。你需要将这些信息写入到具有 600 权限的隐藏文件中，像这样：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkdir <span class="regexp">/media/</span>samba# echo “username=samba_username” &gt; <span class="regexp">/media/</span>samba<span class="regexp">/.smbcredentials# echo “password=samba_password” &gt;&gt; /m</span>edia<span class="regexp">/samba/</span>.smbcredentials# chmod <span class="number">600</span> <span class="regexp">/media/</span>samba<span class="regexp">/.smbcredentials</span></span><br></pre></td></tr></table></figure>
<p>第三步：然后将下面的内容添加到 /etc/fstab 文件中。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="comment">//192.168.0.10/gacanepa /media/samba cifs credentials=/media/samba/.smbcredentials,defaults 0 0</span></span></span><br></pre></td></tr></table></figure>
<p>第四步：现在可以挂载你的 Samba 共享了。手动挂载（mount //192.168.0.10/gacanepa）或者重启系统并应用 /etc/fstab 中相应行来用就挂载都可以。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083736v77ptst9rhocsc7t.png" alt="挂载有密码保护的 Samba 共享"></p>
<p><em>挂载有密码保护的 Samba 共享</em></p>
<h4 id="在-Linux-系统中挂载-NFS-共享"><a href="#在-Linux-系统中挂载-NFS-共享" class="headerlink" title="在 Linux 系统中挂载 NFS 共享"></a>在 Linux 系统中挂载 NFS 共享</h4><p>第一步：在 Red Hat 以 Debian 系发行版中安装 nfs-common 和 portmap 软件包。如下：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum update &amp;&amp; yum install <span class="built_in">nfs</span>-utils <span class="built_in">nfs</span>-utils-lib# aptitude update &amp;&amp; aptitude install <span class="built_in">nfs</span>-common</span><br></pre></td></tr></table></figure>
<p>第二步：为 NFS 共享创建挂载点。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># mkdir /media/nfs</span></span><br></pre></td></tr></table></figure>
<p>第三步：将下面的内容添加到 /etc/fstab 文件中。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span>.<span class="number">0</span>.<span class="number">10</span><span class="symbol">:/NFS-SHARE</span> /media/nfs nfs defaults <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>第四步：现在可以挂载你的 Samba 共享了。手动挂载（mount 192.168.0.10:/NFS-SHARE）或者重启系统并应用 /etc/fstab 中相应行来用就挂载都可以。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/11/083737p4rbohatc5b6cfib.png" alt="挂载 NFS 共享"></p>
<p><em>挂载 NFS 共享</em></p>
<h3 id="永久性挂载文件系统"><a href="#永久性挂载文件系统" class="headerlink" title="永久性挂载文件系统"></a>永久性挂载文件系统</h3><p>像前面两个例子那样，/etc/fstab 控制着Linux如何访问硬盘分区及可移动设备。/etc/fstab 由六个字段的内容组成，各个字段之间通过一个空格符或者制表符来分开。井号（#）开始的行只是会被忽略的注释。</p>
<p>每一行都按照这个格式来写入：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;file system&gt;</span> <span class="section">&lt;mount point&gt;</span> <span class="section">&lt;type&gt;</span> <span class="section">&lt;options&gt;</span> <span class="section">&lt;dump&gt;</span> <span class="section">&lt;pass&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><file system="">: 第一个字段指定挂载的设备。大多数发行版本都通过分区的标卷（label）或者 UUID 来指定。这样做可以避免分区号改变时带来的错误。</file></li>
<li><mount point="">: 第二个字段指定挂载点。</mount></li>
<li><type> ：文件系统的类型代码与 mount 命令挂载文件系统时使用的类型代码是一样的。通过 auto 类型代码可以让内核自动检测文件系统，这对于可移动设备来说非常方便。注意，该选项可能不是对所有文件系统可用。</type></li>
<li><options>: 一个（或多个）挂载选项。</options></li>
<li><dump>: 你可能把这个字段设置为 0（否则设置为 1），使得系统启动时禁用 dump 工具（dump 程序曾经是一个常用的备份工具，但现在越来越少用了）对文件系统进行备份。</dump></li>
<li><pass>: 这个字段指定启动系统是是否通过 fsck 来检查文件系统的完整性。0 表示 fsck 不对文件系统进行检查。数字越大，优先级越低。因此，根分区（/）最可能使用数字 1，其他所有需要检查的分区则是以数字 2.</pass></li>
</ul>
<p><strong>Mount 命令例示</strong></p>
<p>1、在系统启动时，通过 TECMINT 标卷来挂载文件系统，并具备 rw 和 noexec 属性，你应该将以下语句添加到 /etc/fstab 文件中。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">LABEL</span>=TECMINT /mnt ext4 rw,noexec <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>2、若你想在系统启动时挂载 DVD 光驱中的内容，添加以下语句。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/dev/</span>sr0 <span class="meta-keyword">/media/</span>cdrom0 iso9660 ro,user,noauto <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其中 /dev/sr0 为你的 DVD 光驱。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 04：对存储设备分区、格式化文件系统和配置交换分区]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-04/</url>
      <content type="html"><![CDATA[<h3 id="对存储设备分区"><a href="#对存储设备分区" class="headerlink" title="对存储设备分区"></a>对存储设备分区</h3><p>分区是一种将单独的硬盘分成一个或多个区的手段。一个分区只是硬盘的一部分，我们可以认为这部分是独立的磁盘，里边包含一个单一类型的文件系统。分区表则是将硬盘上这些分区与分区标识符联系起来的索引。</p>
<p>在 Linux 上，IBM PC 兼容系统里边用于管理传统 MBR（用到2009年）分区的工具是 fdisk。对于 GPT（2010年至今）分区，我们使用 gdisk。这两个工具都可以通过程序名后面加上设备名称（如 /dev/sdb）进行调用。</p>
<h4 id="使用-fdisk-管理-MBR-分区"><a href="#使用-fdisk-管理-MBR-分区" class="headerlink" title="使用 fdisk 管理 MBR 分区"></a>使用 fdisk 管理 MBR 分区</h4><p>我们先来介绍 fdisk：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># fdisk /dev/sdb</span></span><br></pre></td></tr></table></figure>
<p>然后出现提示说进行下一步操作。若不确定如何操作，按下 “m” 键显示帮助。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052349vh0iosthplod5jiq.png" alt="fdisk 帮助菜单"></p>
<p><em>fdisk 帮助菜单</em></p>
<p>上图中，使用频率最高的选项已高亮显示。你可以随时按下 “p” 显示分区表。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052351wdx8ogb2kdhg5zkx.png" alt="显示分区表"></p>
<p><em>显示分区表</em></p>
<p>Id 列显示由 fdisk 分配给每个分区的分区类型（分区 id）。一个分区类型代表一种文件系统的标识符，简单来说，包括该分区上数据的访问方法。</p>
<p>请注意，每个分区类型的全面讲解将超出了本教程的范围——本系列教材主要专注于 LFCS 测试，以考试为主。</p>
<p><strong>下面列出一些 fdisk 常用选项：</strong></p>
<p>按下 “l”（小写 L）选项来显示所有可以由 fdisk 管理的分区类型。</p>
<p>按下 “d” 可以删除现有的分区。若硬盘上有多个分区，fdisk 将询问你要删除那个分区。</p>
<p>键入对应的数字，并按下 “w” 保存更改（将更改写入分区表）。</p>
<p>在下图的命令中，我们将删除 /dev/sdb2，然后显示（p）分区表来验证更改。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052353nphfjfjf6j1hvnzl.png" alt="fdisk 命令选项"></p>
<p><em>fdisk 命令选项</em></p>
<p>按下 “n” 后接着按下 “p” 会创建新一个主分区。最后，你可以使用所有的默认值（这将占用所有的可用空间），或者像下面一样自定义分区大小。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052355f0a3jjppj9uxbaua.png" alt="创建新分区"></p>
<p><em>创建新分区</em></p>
<p>若 fdisk 分配的分区 Id 并不是我们想用的，可以按下 “t” 来更改。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052357pdqrotrrtrj10ov2.png" alt="更改分区类型"></p>
<p><em>更改分区类型</em></p>
<p>全部设置好分区后，按下 “w” 将更改保存到硬盘分区表上。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052358fjghg3it1oig4ih0.png" alt="保存分区更改"></p>
<p><em>保存分区更改</em></p>
<h4 id="使用-gdisk-管理-GPT-分区"><a href="#使用-gdisk-管理-GPT-分区" class="headerlink" title="使用 gdisk 管理 GPT 分区"></a>使用 gdisk 管理 GPT 分区</h4><p>下面的例子中，我们使用 /dev/sdb。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gdisk /dev/sdb</span></span><br></pre></td></tr></table></figure>
<p>必须注意的是，gdisk 可以用于创建 MBR 和 GPT 两种分区表。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052359wttf81v84mzjj1u8.png" alt="创建 GPT 分区"></p>
<p><em>创建 GPT 分区</em></p>
<p>使用 GPT 分区方案，我们可以在同一个硬盘上创建最多 128 个分区，单个分区最大以 PB 为单位，而 MBR 分区方案最大的只能 2TB。</p>
<p>注意，fdisk 与 gdisk 中大多数命令都是一样的。因此，我们不会详细介绍这些命令选项，而是给出一张使用过程中的截图。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052401jndri4wwzkfi9w1w.png" alt="gdisk 命令选项"></p>
<p><em>gdisk 命令选项</em></p>
<h3 id="格式化文件系统"><a href="#格式化文件系统" class="headerlink" title="格式化文件系统"></a>格式化文件系统</h3><p>一旦创建完需要的分区，我们就必须为分区创建文件系统。查询你所用系统支持的文件系统，请运行：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># ls /sbin/mk*</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052403mudh1vuw1cx0qdsw.png" alt="检查文件系统类型"></p>
<p><em>检查文件系统类型</em></p>
<p>选择文件系统取决于你的需求。你应该考虑到每个文件系统的优缺点以及其特点。选择文件系统需要看的两个重要属性：</p>
<ul>
<li>日志支持，允许从系统崩溃事件中快速恢复数据。</li>
<li>安全增强式 Linux（SELinux）支持，按照项目 wiki 所说，“安全增强式 Linux 允许用户和管理员更好的控制访问控制权限”。</li>
</ul>
<p>在接下来的例子中，我们通过 mkfs 在 /dev/sdb1 上创建 ext4 文件系统（支持日志和 SELinux），标卷为 Tecmint。mkfs 基本语法如下：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs -t <span class="string">[filesystem]</span> -L <span class="string">[label]</span> device或者# mkfs.<span class="string">[filesystem]</span> -L <span class="string">[label]</span> device</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052406lvtvyrztb7kymx9v.png" alt="创建 ext4 文件系统"></p>
<p><em>创建 ext4 文件系统</em></p>
<h3 id="创建并启用交换分区"><a href="#创建并启用交换分区" class="headerlink" title="创建并启用交换分区"></a>创建并启用交换分区</h3><p>要让 Linux 系统访问虚拟内存，则必须有一个交换分区，当内存（RAM）用完的时候，将硬盘中指定分区（即 Swap 分区）当做内存来使用。因此，当有足够的系统内存（RAM）来满足系统的所有的需求时，我们并不需要划分交换分区。尽管如此，是否使用交换分区取决于管理员。</p>
<p>下面列出选择交换分区大小的经验法则：</p>
<blockquote>
<p>物理内存不高于 2GB 时，取两倍物理内存大小即可；物理内存在 2GB 以上时，取一倍物理内存大小即可；并且所取大小应该大于 32MB。</p>
</blockquote>
<p>所以，如果：</p>
<p>M为物理内存大小，S 为交换分区大小，单位 GB，那么：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若 <span class="keyword">M</span> &lt; 2    S = <span class="keyword">M</span> *2否则    S = <span class="keyword">M</span> + 2</span><br></pre></td></tr></table></figure>
<p>记住，这只是基本的经验。对于作为系统管理员的你，才是决定是否使用交换分区及其大小的关键。</p>
<p>要配置交换分区，首先要划分一个常规分区，大小像我们之前演示的那样来选取。然后添加以下条目到 /etc/fstab 文件中（其中的 X 要更改为对应的 b 或 c）。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdX1 <span class="keyword">swap</span> <span class="keyword">swap</span> sw <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>最后，格式化并启用交换分区：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"># mkswap /dev/sdX1</span><span class="attr"># swapon -v /dev/sdX1</span></span><br></pre></td></tr></table></figure>
<p>显示交换分区的快照：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /proc/swaps</span></span><br></pre></td></tr></table></figure>
<p>关闭交换分区：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># swapoff /dev/sdX1</span></span><br></pre></td></tr></table></figure>
<p>下面的例子，我们会使用 fdisk 将 /dev/sdc1（512MB，系统和内存为 256MB）来设置交换分区，下面是我们之前详细提过的步骤。注意，这种情况下我们使用的是指定大小分区。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052408cc688zfk1zz6opp6.png" alt="创建交换分区"></p>
<p><em>创建交换分区</em></p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201604/04/052410nqiabadsn3376kwz.png" alt="启用交换分区"></p>
<p><em>启用交换分区</em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 03：归档/压缩文件及目录、设置文件属性和搜索文件]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-03/</url>
      <content type="html"><![CDATA[<h3 id="归档和压缩的相关工具"><a href="#归档和压缩的相关工具" class="headerlink" title="归档和压缩的相关工具"></a>归档和压缩的相关工具</h3><p>文件归档工具将一堆文件整合到一个单独的归档文件之后，我们可以将归档文件备份到不同类型的介质或者通过网络传输和发送 Email 来备份。在 Linux 中使用频率最高的归档实用工具是 tar。当归档工具和压缩工具一起使用的时候，可以减少同一文件和信息在硬盘中的存储空间。</p>
<h4 id="tar-使用工具"><a href="#tar-使用工具" class="headerlink" title="tar 使用工具"></a>tar 使用工具</h4><p>tar 将一组文件打包到一个单独的归档文件（通常叫做 tar 文件或者 tarball）。tar 这个名称最初代表磁带存档程序tape archiver，但现在我们可以用它来归档任意类型的可读写介质上边的数据，而不是只能归档磁带数据。tar 通常与 gzip、bzip2 或者 xz 等压缩工具一起使用，生成一个压缩的 tarball。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar <span class="string">[选项]</span> <span class="string">[路径名 ...]</span></span><br></pre></td></tr></table></figure>
<p>其中 … 代表指定哪些文件进行归档操作的表达式</p>
<h4 id="tar-的常用命令"><a href="#tar-的常用命令" class="headerlink" title="tar 的常用命令"></a>tar 的常用命令</h4><table>
<thead>
<tr>
<th>长选项</th>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-create</td>
<td>c</td>
<td>创建 tar 归档文件</td>
</tr>
<tr>
<td>-concatenate</td>
<td>A</td>
<td>将一存档与已有的存档合并</td>
</tr>
<tr>
<td>-append</td>
<td>r</td>
<td>把要存档的文件追加到归档文件的末尾</td>
</tr>
<tr>
<td>-update</td>
<td>u</td>
<td>更新新文件到归档文件中去</td>
</tr>
<tr>
<td>-diff 或 -compare</td>
<td>d</td>
<td>比较存档与当前文件的不同之处</td>
</tr>
<tr>
<td>-file archive</td>
<td>f</td>
<td>使用档案文件或归档设备</td>
</tr>
<tr>
<td>-list</td>
<td>t</td>
<td>列出 tarball 中的内容</td>
</tr>
<tr>
<td>-extract 或 -get</td>
<td>x</td>
<td>从归档文件中释放文件</td>
</tr>
</tbody>
</table>
<h4 id="常用的操作修饰符"><a href="#常用的操作修饰符" class="headerlink" title="常用的操作修饰符"></a>常用的操作修饰符</h4><table>
<thead>
<tr>
<th>长选项</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-directory dir</td>
<td>C</td>
<td>执行归档操作前，先转到指定目录</td>
</tr>
<tr>
<td>-same-permissions</td>
<td>p</td>
<td>保持原始的文件权限</td>
</tr>
<tr>
<td>-verbose</td>
<td>v</td>
<td>列出所有的读取或提取的文件。但这个标识符与 -list 一起使用的时候，还会显示出文件大小、属主和时间戳的信息</td>
</tr>
<tr>
<td>-verify</td>
<td>W</td>
<td>写入存档后进行校验</td>
</tr>
<tr>
<td>-exclude file</td>
<td></td>
<td>不把指定文件包含在内</td>
</tr>
<tr>
<td>-exclude=pattern</td>
<td>X</td>
<td>以PATTERN模式排除文件</td>
</tr>
<tr>
<td>-gzip 或 -gunzip</td>
<td>z</td>
<td>通过gzip压缩归档</td>
</tr>
<tr>
<td>-bzip2</td>
<td>j</td>
<td>通过bzip2压缩归档</td>
</tr>
<tr>
<td>-xz</td>
<td>J</td>
<td>通过xz压缩归档</td>
</tr>
</tbody>
</table>
<p>Gzip 是最古老的压缩工具，压缩率最小，bzip2 的压缩率稍微高一点。另外，xz 是最新的压缩工具，压缩率最好。xz 具有最佳压缩率的代价是：完成压缩操作花费最多时间，压缩过程中占有较多系统资源。</p>
<p>通常，通过这些工具压缩的 tar 文件相应的具有 .gz、.bz2 或 .xz的扩展名。在下列的例子中，我们使用 file1、file2、file3、file4 和 file5 进行演示。</p>
<p><strong>通过 gzip、bzip2 和 xz 压缩归档</strong></p>
<p>归档当前工作目录的所有文件，并以 gzip、bzip2 和 xz 压缩刚刚的归档文件（请注意，用正则表达式来指定哪些文件应该归档——这是为了防止将归档工具包前一步生成的文件打包进来）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">tar</span> <span class="selector-tag">czf</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span> <span class="selector-tag">file</span><span class="selector-attr">[0-9]</span># <span class="selector-tag">tar</span> <span class="selector-tag">cjf</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span> <span class="selector-tag">file</span><span class="selector-attr">[0-9]</span># <span class="selector-tag">tar</span> <span class="selector-tag">cJf</span> <span class="selector-tag">myfile</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span> <span class="selector-tag">file</span><span class="selector-attr">[0-9]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060134vs1uuyu23ag1yavk.png" alt="压缩多个文件"></p>
<p><em>压缩多个文件</em></p>
<p><strong>列举 tarball 中的内容和更新/追加文件到归档文件中</strong></p>
<p>列举 tarball 中的内容，并显示相同信息为一个详细目录清单。注意，不能直接向压缩的归档文件更新/追加文件（若你需要向压缩的 tarball 中更新/追加文件，需要先解压 tar 文件后再进行操作，然后重新压缩）。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># tar tvf [tarball]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060135zzi6hlbo6ylmo0eh.png" alt="列举归档文件中的内容"></p>
<p><em>列举归档文件中的内容</em></p>
<p>运行一下任意一条命令：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">gzip</span> <span class="selector-tag">-d</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>    <span class="selector-attr">[#1]</span># <span class="selector-tag">bzip2</span> <span class="selector-tag">-d</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span>  <span class="selector-attr">[#2]</span># <span class="selector-tag">xz</span> <span class="selector-tag">-d</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span><span class="selector-class">.xz</span>      <span class="selector-attr">[#3]</span></span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">tar</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">delete</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">file</span> <span class="comment">myfiles</span><span class="string">.</span><span class="comment">tar</span> <span class="comment">file4</span> <span class="comment">(删除tarball中的file4)#</span> <span class="comment">tar</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">update</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">file</span> <span class="comment">myfiles</span><span class="string">.</span><span class="comment">tar</span> <span class="comment">file4</span> <span class="comment">(更新tarball中的file4)</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">gzip</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span>      <span class="selector-attr">[ 如果你运行 #1 命令 ]</span># <span class="selector-tag">bzip2</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span>     <span class="selector-attr">[ 如果你运行 #2 命令 ]</span># <span class="selector-tag">xz</span> <span class="selector-tag">myfiles</span><span class="selector-class">.tar</span>        <span class="selector-attr">[ 如果你运行 #3 命令 ]</span></span><br></pre></td></tr></table></figure>
<p>最后</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># tar tvf [tarball] #再次</span></span><br></pre></td></tr></table></figure>
<p>将 file4 修改后的日期和时间与之前显示的对应信息进行比较</p>
<p><strong>排除文件类型</strong></p>
<p>假设你现在需要备份用户的家目录。一个有经验的系统管理员会选择忽略所有视频和音频文件再备份（也可能是公司规定）。</p>
<p>可能你最先想到的方法是在备份的时候，忽略扩展名为 .mp3 和 .mp4（或者其他格式）的文件。但如果你有些自作聪明的用户将扩展名改为 .txt 或者 .bkp，那你的方法就不灵了。为了发现并排除音频或者视频文件，你需要先检查文件类型。以下 shell 脚本可以代你完成类型检查：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash# 把需要进行备份的目录传递给 <span class="string">$1</span> 参数.<span class="type">DIR</span>=<span class="string">$1</span># 排除文件类型中包含了 mpeg 字符串的文件，然后创建 tarball 并进行压缩。# -若文件类型中包含 mpeg 字符串， <span class="string">$?</span>（最后执行的命令的退出状态）返回 <span class="number">0</span>，然后文件名被定向到排除选项。否则返回 <span class="number">1</span>。# -若 <span class="string">$?</span> 等于 <span class="number">0</span>，该文件从需要备份文件的列表排除。tar <span class="type">X</span> &lt;(for i in <span class="string">$D</span>IR/*; do file <span class="string">$i</span> | grep -i mpeg; if [ <span class="string">$?</span> -eq <span class="number">0</span> ]; then echo <span class="string">$i</span>; fi;done) -cjf backupfile.tar.bz2 <span class="string">$D</span>IR/*</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060136fle3keeeed4e4fem.png" alt="排除文件进行备份"></p>
<p><em>排除文件进行备份</em></p>
<p><strong>使用 tar 保持文件的原有权限进行恢复</strong></p>
<p>通过以下命令，你可以保留文件的权限将备份文件恢复到原始用户的家目录（本例是 user_restore）。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">tar</span> <span class="comment">xjf</span> <span class="comment">backupfile</span><span class="string">.</span><span class="comment">tar</span><span class="string">.</span><span class="comment">bz2</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">directory</span> <span class="comment">user_restore</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">same</span><span class="literal">-</span><span class="comment">permissions</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060137gu536aywqqzua4o3.png" alt="从归档文件中恢复"></p>
<p><em>从归档文件中恢复</em></p>
<p><strong>扩展阅读：</strong></p>
<ul>
<li><a href="http://www.tecmint.com/18-tar-command-examples-in-linux/" target="_blank" rel="external">18 tar Command Examples in Linux</a></li>
<li><a href="http://www.tecmint.com/dtrx-an-intelligent-archive-extraction-tar-zip-cpio-rpm-deb-rar-tool-for-linux/" target="_blank" rel="external">Dtrx – An Intelligent Archive Tool for Linux</a></li>
</ul>
<h3 id="通过-find-命令搜索文件"><a href="#通过-find-命令搜索文件" class="headerlink" title="通过 find 命令搜索文件"></a>通过 find 命令搜索文件</h3><p>find 命令用于递归搜索目录树中包含指定字符的文件和目录，然后在屏幕显示出于指定字符相匹配的文件和目录，或者在匹配项进行其他操作。</p>
<p>通常，我们通过文件名、文件的属主、属组、类型权限、日期及大小来搜索。</p>
<h4 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># find <span class="string">[需搜索的目录]</span> <span class="string">[表达式]</span></span><br></pre></td></tr></table></figure>
<p><strong>通过文件大小递归搜索文件</strong></p>
<p>以下命令会搜索当前目录（.）及其下两层子目录（-maxdepth 3，包含当前目录及往下两层的子目录）中大于 2 MB（-size +2M）的所有文件（-f）。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="built_in">find</span> . -maxdepth <span class="number">3</span> -<span class="built_in">type</span> f -size +<span class="number">2</span>M</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060137g7kn5dyn47n2774i.png" alt="Find Files by Size in Linux"> <em> 通过文件大小搜索文件</em></p>
<p><em>Find Files by Size in Linux</em></p>
<p><strong>搜索符合一定规则的文件并将其删除</strong></p>
<p>有时候，777 权限的文件通常为外部攻击者打开便利之门。不管是以何种方式，让所有人都可以对文件进行任意操作都是不安全的。对此，我们采取一个相对激进的方法——删除这些文件（’{}’ + 用来“聚集”搜索的结果）。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">find</span> <span class="regexp">/home/u</span>ser -perm <span class="number">777</span> -exec rm <span class="string">'&#123;&#125;'</span> +</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060138y7dxlpzxm3mgqgmm.png" alt="搜索 777 权限的文件"></p>
<p><em>搜索 777 权限的文件</em></p>
<p><strong>按访问时间和修改时间搜索文件</strong></p>
<p>搜索 /etc 目录下访问时间（-atime）或修改时间（-mtime）大于（+180）或小于（-180） 6 个月或者刚好（180） 6 个月的配置文件。</p>
<p>按照下面例子对命令进行修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="built_in">find</span> /etc -iname <span class="string">"*.conf"</span> -mtime -<span class="number">180</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060139c70syyslkdqyyl9y.png" alt="按修改时间搜索文件"></p>
<p><em>按修改时间搜索文件</em></p>
<ul>
<li>扩展阅读： <a href="http://www.tecmint.com/35-practical-examples-of-linux-find-command/" target="_blank" rel="external">35 Practical Examples of Linux ‘find’ Command</a></li>
</ul>
<h3 id="文件权限及基本属性"><a href="#文件权限及基本属性" class="headerlink" title="文件权限及基本属性"></a>文件权限及基本属性</h3><p>ls -l 命令输出的前 10 位字符是文件的属性，其中第一个字符用来表明文件的类型。</p>
<ul>
<li>– : 普通文件</li>
<li>-d : 目录</li>
<li>-l : 符号链接</li>
<li>-c : 字符设备 (它将数据作为字节流处理，如terminal)</li>
<li>-b : 块设备 (在块设备中处理数据，如存储设备)</li>
</ul>
<p>接下来表示文件属性的 9 位字符叫做文件的读写模式，代表文件属主、同组用户和其他用户（通常指的是“外部世界”）对应的读（r）、写（w）和执行（x）权限。</p>
<p>文件的写权限允许对应的用户对文件进行打开和读写，对于同时设置了执行权限的目录，对应用户可以列举出该目录的内容。另外，文件的执行权限允许将文件当做是一个可执行程序来运行，而目录的执行权限则是允许用户进入和退出该目录。</p>
<p>文件的权限通过 chown 命令来更改，其基本语法如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chmod [new_mode] file</span></span><br></pre></td></tr></table></figure>
<p>new_mode 可以是 3 位八进制数值或者对应权限的表达式。</p>
<p>八进制数值可以从二进制数值进行等值转换，通过下列方法来计算文件属主、同组用户和其他用户权限对应的二进制数值：</p>
<p>一个确定权限的二进制数值表现为 2 的幂（r=2^2，w=2^1，x=2^0），当权限省缺时，二进制数值为 0。如下：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060139dd60ep3ndk447xdf.png" alt="文件权限"></p>
<p><em>文件权限</em></p>
<p>使用八进制数值设置上图的文件权限，请输入：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chmod 744 myfile</span></span><br></pre></td></tr></table></figure>
<p>通过 u、g 和 o 分别代表用户、同组用户和其他用户，然后你也可以使用权限表达式来单独对用户设置文件的权限模式。也可以通过 a 代表所有用户，然后设置文件权限。通过 + 号或者 - 号相应的赋予或移除文件权限。</p>
<p><strong>为所有用户撤销一个 shell 脚本的执行权限</strong></p>
<p>正如之前解释的那样，我们可以通过 - 号为需要移除权限的属主、同组用户、其他用户或者所有用户去掉指定的文件权限。下面命令中的短横线（-）可以理解为：移除（-）所有用户（a）的 backup.sh 文件执行权限（x）。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod a-x backup.sh</span></span><br></pre></td></tr></table></figure>
<p>下面演示为文件属主、同组用户赋予读、写和执行权限，并赋予其他用户读权限。</p>
<p>当我们使用 3 位八进制数值为文件设置权限的时候，第一位数字代表属主权限，第二位数字代表同组用户权限，第三位数字代表其他用户的权限：</p>
<ul>
<li>属主：(r=2^2 + w=2^1 + x=2^0 = 7)</li>
<li>同组用户：(r=2^2 + w=2^1 + x=2^0 = 7)</li>
<li>其他用户：(r=2^2 + w=0 + x=0 = 4)</li>
</ul>
<p>命令如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chmod 774 myfile</span></span><br></pre></td></tr></table></figure>
<p>随着练习时间的推移，你会知道何种情况下使用哪种方式来更改文件的权限模式的效果最好。</p>
<p>使用 ls -l 详细列举目录详细同样会显示出文件的属主和属组（这个很基本，而且影响到系统文件的访问控制）。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/30/060140latew4zef3xt3ar6.png" alt="列举 Linux 文件"></p>
<p><em>列举 Linux 文件</em></p>
<p>通过 chown 命令可以对文件的归属权进行更改，可以同时或者分开更改属主和属组。其基本语法为：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># chown user:<span class="keyword">group</span> <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>至少要指定用户或者用户组</p>
<p><strong>举几个例子：</strong></p>
<p>将文件的属主更改为指定用户：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chown gacanepa sent</span></span><br></pre></td></tr></table></figure>
<p>同时将文件的属主和属组更改为指定的用户和组：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># chown gacanepa:gacanepa TestFile</span></span><br></pre></td></tr></table></figure>
<p>只将文件的属组更改为指定组。注意组名前的冒号（:）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">chown</span> <span class="selector-pseudo">:gacanepa</span> <span class="selector-tag">email_body</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 02：如何安装和使用纯文本编辑器 vi/vim]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-02/</url>
      <content type="html"><![CDATA[<h3 id="使用-vi-vim-执行基本的文件编辑操作"><a href="#使用-vi-vim-执行基本的文件编辑操作" class="headerlink" title="使用 vi/vim 执行基本的文件编辑操作"></a>使用 vi/vim 执行基本的文件编辑操作</h3><p>vi 是为 Unix 而生的第一个全屏文本编辑器。它的设计小巧简单，对于仅仅使用过诸如 NotePad++ 或 gedit 等图形界面的文本编辑器的用户来说，使用起来可能存在一些困难。</p>
<p>为了使用 vi，我们必须首先理解这个强大的程序操作中的三种模式，方便我们后边学习这个强大的文本处理软件的相关操作。</p>
<p>请注意，大多数的现代 Linux 发行版都集成了 vi 的变种——— vim（改进版 VIVi IMproved），相比于 vi，它有更多新功能。所以，我们会在本教程中交替使用 vi 和 vim。</p>
<p>如果你的发行版还没有安装 vim，你可以通过以下方法来安装：</p>
<ul>
<li>Ubuntu 及其衍生版：apt-get update &amp;&amp; apt-get install vim</li>
<li>以 Red-Hat 为基础的发行版：yum update &amp;&amp; yum install vim</li>
<li>openSUSE ：zypper update &amp;&amp; zypper install vim</li>
</ul>
<h3 id="我为什么要学习-vi"><a href="#我为什么要学习-vi" class="headerlink" title="我为什么要学习 vi"></a>我为什么要学习 vi</h3><p>至少有以下两个理由：</p>
<ol>
<li>因为它是 POSIX 标准的一部分，所以不管你使用什么发行版 vi 总是可用的。</li>
<li>vi 基本不消耗多少系统资源，并且允许我们仅仅通过键盘来完成任何可能的任务。</li>
</ol>
<p>此外，vi 有着非常丰富的内置帮助手册，程序打开后就可以通过 <code>:help</code> 命令来查看。这个内置帮助手册比 vi/vim 的 man 页面包含了更多信息。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053547pjeg7wb5qwtzc0rc.png" alt="vi Man 页面"></p>
<p><em>vi Man 页面</em></p>
<h4 id="启动-vi"><a href="#启动-vi" class="headerlink" title="启动 vi"></a>启动 vi</h4><p>可以通过在命令提示符下输入 vi 来启动。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053547utc985cm8c8n52nm.png" alt="使用 vi 编辑器"></p>
<p><em>使用 vi 编辑器</em></p>
<p>然后按下字母 i，你就可以开始输入了。或者通过下面的方法来启动 vi：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vi filename</span></span><br></pre></td></tr></table></figure>
<p>这样会打开一个名为 filename 的缓存区buffer（稍后会详细介绍缓存区），在你编辑完成之后就可以存储在磁盘中了。</p>
<h4 id="理解-vi-的三个模式"><a href="#理解-vi-的三个模式" class="headerlink" title="理解 vi 的三个模式"></a>理解 vi 的三个模式</h4><ol>
<li>在命令command模式中，vi 允许用户浏览该文件并输入由一个或多个字母组成的、简短的、大小写敏感的 vi 命令。这些命令的大部分都可以增加一个前缀数字表示执行次数。<br>比如：<code>yy</code>（或<code>Y</code>） 复制当前的整行，<code>3yy</code>（或<code>3Y</code>） 复制当前整行和下边紧接着的两行（总共3行）。通过 <code>Esc</code>键可以随时进入命令模式（而不管当前工作在什么模式下）。事实上，在命令模式下，键盘上所有的输入都被解释为命令而非文本，这往往使得初学者困惑不已。</li>
<li>在末行ex模式中，我们可以处理文件（包括保存当前文件和运行外部程序）。我们必须在命令模式下输入一个冒号（<code>:</code>），才能进入这个模式，紧接着是要在末行模式下使用的命令。执行之后 vi 自动回到命令模式。</li>
<li>在文本输入insert模式（通常在命令模式下使用字母 <code>i</code> 进入这个模式）中，我们可以随意输入文本。大多数的键入将以文本形式输出到屏幕（一个重要的例外是<code>Esc</code>键，它将退出文本编辑模式并回到命令模式）。</li>
</ol>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053548zzn3t0oq01qtfq1a.png" alt="vi 文本插入模式"></p>
<p><em>vi 文本插入模式</em></p>
<h4 id="vi-命令"><a href="#vi-命令" class="headerlink" title="vi 命令"></a>vi 命令</h4><p>下面的表格列出常用的 vi 命令。文件编辑的命令可以通过添加叹号的命令强制执行（如，<code>:q!</code> 命令强制退出编辑器而不保存文件）。</p>
<table>
<thead>
<tr>
<th>关键命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>h</code> 或 ←</td>
<td>光标左移一个字符</td>
</tr>
<tr>
<td><code>j</code> 或 ↓</td>
<td>光标下移一行</td>
</tr>
<tr>
<td><code>k</code> 或 ↑</td>
<td>光标上移一行</td>
</tr>
<tr>
<td><code>l</code> (小写字母 L) 或 →</td>
<td>光标右移一个字符</td>
</tr>
<tr>
<td><code>H</code></td>
<td>光标移至屏幕顶行</td>
</tr>
<tr>
<td><code>L</code></td>
<td>光标移至屏幕末行</td>
</tr>
<tr>
<td><code>G</code></td>
<td>光标移至文件末行</td>
</tr>
<tr>
<td><code>w</code></td>
<td>光标右移一个词</td>
</tr>
<tr>
<td><code>b</code></td>
<td>光标左移一个词</td>
</tr>
<tr>
<td><code>0</code> (数字零)</td>
<td>光标移至行首</td>
</tr>
<tr>
<td><code>^</code></td>
<td>光标移至当前行第一个非空格字符</td>
</tr>
<tr>
<td><code>$</code></td>
<td>光标移至当前行行尾</td>
</tr>
<tr>
<td><code>Ctrl-B</code></td>
<td>向后翻页</td>
</tr>
<tr>
<td><code>Ctrl-F</code></td>
<td>向前翻页</td>
</tr>
<tr>
<td><code>i</code></td>
<td>在光标所在位置插入文本</td>
</tr>
<tr>
<td><code>I</code> (大写字母 i)</td>
<td>在当前行首插入文本</td>
</tr>
<tr>
<td><code>J</code> (大写字母 j)</td>
<td>将下一行与当前行合并（下一行上移到当前行）</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标所在位置后追加文本</td>
</tr>
<tr>
<td><code>o</code> (小写字母 O)</td>
<td>在当前行下边插入空白行</td>
</tr>
<tr>
<td><code>O</code> (大写字母 O)</td>
<td>在当前行上边插入空白行</td>
</tr>
<tr>
<td><code>r</code></td>
<td>替换光标所在位置的一个字符</td>
</tr>
<tr>
<td><code>R</code></td>
<td>从光标所在位置开始覆盖插入文本</td>
</tr>
<tr>
<td><code>x</code></td>
<td>删除光标所在位置的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>立即删除光标所在位置之前（左边）的一个字符</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>剪切当前整行文本（为了之后进行粘贴）</td>
</tr>
<tr>
<td><code>D</code></td>
<td>剪切光标所在位置到行末的文本（该命令等效于 <code>d$</code>）</td>
</tr>
<tr>
<td><code>yX</code></td>
<td>给出一个移动命令 X （如 <code>h</code>、<code>j</code>、<code>H</code>、<code>L</code> 等），复制适当数量的字符、单词或者从光标开始到一定数量的行</td>
</tr>
<tr>
<td><code>yy</code> 或 <code>Y</code></td>
<td>复制当前整行</td>
</tr>
<tr>
<td><code>p</code></td>
<td>粘贴在光标所在位置之后（下一行）</td>
</tr>
<tr>
<td><code>P</code></td>
<td>粘贴在光标所在位置之前（上一行）</td>
</tr>
<tr>
<td><code>.</code> (句点)</td>
<td>重复最后一个命令</td>
</tr>
<tr>
<td><code>u</code></td>
<td>撤销最后一个命令</td>
</tr>
<tr>
<td><code>U</code></td>
<td>撤销最后一行的最后一个命令，只有光标仍在最后一行才能执行。</td>
</tr>
<tr>
<td><code>n</code></td>
<td>在查找中跳到下一个匹配项</td>
</tr>
<tr>
<td><code>N</code></td>
<td>在查找中跳到前一个匹配项</td>
</tr>
<tr>
<td><code>:n</code></td>
<td>下一个文件，编辑多个指定文件时，该命令加载下一个文件。</td>
</tr>
<tr>
<td><code>:e file</code></td>
<td>加载新文件来替代当前文件</td>
</tr>
<tr>
<td><code>:r file</code></td>
<td>将新文件的内容插入到光标所在位置的下一行</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出并放弃更改</td>
</tr>
<tr>
<td><code>:w file</code></td>
<td>将当期打开的缓存区保存为file。如果是追加到已存在的文件中，则使用 ：<code>w &gt;&gt; file</code> 命令</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td>保存当前文件的内容并退出。等效于 <code>x!</code> 和 <code>ZZ</code></td>
</tr>
<tr>
<td><code>:r! command</code></td>
<td>执行 command 命令，并将命令的输出插入到光标所在位置的下一行</td>
</tr>
</tbody>
</table>
<h4 id="vi-选项"><a href="#vi-选项" class="headerlink" title="vi 选项"></a>vi 选项</h4><p>下列选项可以让你在运行 Vim 的时候很方便（需要写入到 <code>~/.vimrc</code> 文件）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">echo</span> <span class="keyword">set</span> <span class="keyword">number</span> &gt;&gt; ~/.vimrc# <span class="keyword">echo</span> <span class="keyword">syntax</span> <span class="keyword">on</span> &gt;&gt; ~/.vimrc# <span class="keyword">echo</span> <span class="keyword">set</span> tabstop=<span class="number">4</span> &gt;&gt; ~/.vimrc# <span class="keyword">echo</span> <span class="keyword">set</span> autoindent &gt;&gt; ~/.vimrc</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053548fbvu7v4ertee4ep4.png" alt="vi编辑器选项"></p>
<p><em>vi编辑器选项</em></p>
<ul>
<li>set number 当 vi 打开或新建文件时，显示行号。</li>
<li>syntax on 打开语法高亮（对应多个文件扩展名），以便源码文件和配置文件更具可读性。</li>
<li>set tabstop=4 设置制表符间距为 4 个空格（默认为 8）。</li>
<li>set autoindent 将前一行的缩进应用于下一行。</li>
</ul>
<h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><p>vi 具有通过查找将光标移动到（在单独一行或者整个文件中的）指定位置。它还可自动或者通过用户确认来执行文本替换。</p>
<p>a) 在行内查找。<code>f</code> 命令在当前行查找指定字符，并将光标移动到指定字符出现的位置。</p>
<p>例如，命令 <code>fh</code> 会在本行中将光标移动到字母<code>h</code>下一次出现的位置。注意，字母 <code>f</code> 和你要查找的字符都不会出现在屏幕上，但是当你按下回车的时候，要查找的字符会被高亮显示。</p>
<p>比如，以下是在命令模式按下 <code>f4</code> 之后的结果。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053548r3ceopcooec9ojkj.png" alt="在 vi 中查找字符"></p>
<p><em>在 vi 中查找字符</em></p>
<p>b) 在整个文件内查找。使用 <code>/</code> 命令，紧接着需要查找的单词或短语。这个查找可以通过使用 <code>n</code> 命令或者 <code>N</code> 重复查找上一个查找的字符串。以下是在命令模式键入 <code>/Jane</code> 的查找结果。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053549r7ge0opbzpadbbdo.png" alt="在 vi 中查找字符"></p>
<p><em>在 vi 中查找字符</em></p>
<p>c) vi 通过使用命令来完成多行或者整个文件的替换操作（类似于 sed）。我们可以使用以下命令，使得整个文件中的单词 “old” 替换为 “young”。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:%s/old/young/g</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：冒号位于命令的最前面。</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053549avni9nwn993ondir.png" alt="vi 的查找和替换"></p>
<p><em>vi 的查找和替换</em></p>
<p>冒号 (<code>:</code>) 进入末行模式，在本例中 <code>s</code> 表示替换，<code>%</code> 是从第一行到最后一行的表示方式（也可以使用 nm 表示范围，即第 n 行到第 m 行），old 是查找模式，young 是用来替换的文本，<code>g</code> 表示在每个查找出来的字符串都进行替换。</p>
<p>另外，在命令最后增加一个 <code>c</code>，可以在每一个匹配项替换前进行确认。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:%s/old/young/gc</span></span><br></pre></td></tr></table></figure>
<p>将旧文本替换为新文本前，vi/vim 会向我们显示以下信息：</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053550azrb7tbuuu7brub5.png" alt="vi 中替换字符串"></p>
<p><em>vi 中替换字符串</em></p>
<ul>
<li><code>y</code>: 执行替换（yes）</li>
<li><code>n</code>: 跳过这个匹配字符的替换并转到下一个（no）</li>
<li><code>a</code>: 在当前匹配字符及后边的相同项全部执行替换</li>
<li><code>q</code> 或 <code>Esc</code>: 取消替换</li>
<li><code>l</code> (小写 L): 执行本次替换并退出</li>
<li><code>Ctrl-e</code>, <code>Ctrl-y</code>: 下翻页，上翻页，查看相应的文本来进行替换</li>
</ul>
<h4 id="同时编辑多个文件"><a href="#同时编辑多个文件" class="headerlink" title="同时编辑多个文件"></a>同时编辑多个文件</h4><p>我们在命令提示符输入 vim file1 file2 file3 如下：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vim file1 file2 file3</span></span><br></pre></td></tr></table></figure>
<p>vim 会首先打开 file1，要跳到 file2 需用 <code>:n</code> 命令。当需要打开前一个文件时，<code>:N</code> 就可以了。</p>
<p>为了从 file1 跳到 file3</p>
<p>a) <code>:buffers</code> 命令会显示当前正在编辑的文件列表</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:buffers</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/29/053550mluqcbuqataceicf.png" alt="编辑多个文件"></p>
<p><em>编辑多个文件</em></p>
<p>b) <code>:buffer 3</code> 命令（后边没有 s）会打开第三个文件 file3 进行编辑。</p>
<p>在上边的图片中，标记符号 <code>#</code> 表示该文件当前已被打开，但是是在后台，而 <code>%a</code> 标记的文件是正在被编辑的。另外，文件号（如上边例子的 3）后边的空格表示该文件还没有被打开。</p>
<h4 id="vi-的临时缓存区"><a href="#vi-的临时缓存区" class="headerlink" title="vi 的临时缓存区"></a>vi 的临时缓存区</h4><p>（LCTT 译注：临时缓存区，也叫做“命名缓存区”，或“寄存器register”）</p>
<p>为了复制连续的多行（比如，假设为 4 行）到一个名为 a 的临时缓存区（与文件无关），并且还要将这些行粘贴到在当前 vi 会话文件中的其它位置，我们需要：</p>
<ol>
<li>按下 <code>Esc</code> 键以确认 vi 处在命令模式</li>
<li>将光标放在我们希望复制的第一行文本</li>
<li>输入 <code>&quot;a4yy</code> 复制当前行和接下来的 3 行，进入一个名为 a 的缓存区。我们可以继续编辑我们的文件————我们不需要立即插入刚刚复制的行。</li>
<li>当到了需要使用刚刚复制的那些行的位置，在 <code>p</code>(小写)或 <code>P</code>(大写)命令前使用<code>&quot;a</code>来将复制行插入到名为 a 的 缓存区：<ul>
<li>输入 <code>&quot;ap</code>，复制行将插入到光标位置所在行的下一行。</li>
<li>输入 <code>&quot;aP</code>，复制行将插入到光标位置所在行的上一行。</li>
</ul>
</li>
</ol>
<p>如果愿意，我们可以重复上述步骤，将缓存区 a 中的内容插入到我们文件的多个位置。像本节中这样的一个临时缓存区，会在当前窗口关闭时释放掉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LFCS 01：如何在 Linux 上使用 GNU sed 等命令来创建、编辑和操作文件]]></title>
      <url>http://qiankun.space/2016/07/29/lfcs-01/</url>
      <content type="html"><![CDATA[<h3 id="处理-Linux-中的文本流"><a href="#处理-Linux-中的文本流" class="headerlink" title="处理 Linux 中的文本流"></a>处理 Linux 中的文本流</h3><p>Linux 将程序中的输入和输出当成字符流或者字符序列。在开始理解重定向和管道之前，我们必须先了解三种最重要的I/O（输入和输出Input and Output）流，事实上，它们都是特殊的文件（根据 UNIX 和 Linux 中的约定，数据流和外围设备（设备文件）也被视为普通文件）。</p>
<p>在 &gt; (重定向操作符) 和 | (管道操作符)之间的区别是：前者将命令与文件相连接，而后者将命令的输出和另一个命令相连接。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr"># command &gt; file# command1</span> | comma<span class="symbol">nd2</span></span><br></pre></td></tr></table></figure>
<p>由于重定向操作符会静默地创建或覆盖文件，我们必须特别小心谨慎地使用它，并且永远不要把它和管道混淆起来。在 Linux 和 UNIX 系统上管道的优势是：第一个命令的输出不会写入一个文件而是直接被第二个命令读取。</p>
<p>在下面的操作练习中，我们将会使用这首诗——《A happy child》（作者未知)</p>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055317sx248jjs2c4c7uu7.png" alt="cat 命令样例"></p>
<p><em>cat 命令样例</em></p>
<h4 id="使用-sed"><a href="#使用-sed" class="headerlink" title="使用 sed"></a>使用 sed</h4><p>sed 是流编辑器stream editor的缩写。为那些不懂术语的人额外解释一下，流编辑器是用来在一个输入流（文件或者管道中的输入）执行基本的文本转换的工具。</p>
<p>sed 最基本的用法是字符替换。我们将通过把每个出现的小写 y 改写为大写 Y 并且将输出重定向到 ahappychild2.txt 开始。g 标志表示 sed 应该替换文件每一行中所有应当替换的实例。如果这个标志省略了，sed 将会只替换每一行中第一次出现的实例。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># sed <span class="string">'s/term/replacement/flag'</span> file</span></span><br></pre></td></tr></table></figure>
<p><strong>我们的样例：</strong></p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># sed <span class="string">'s/y/Y/g'</span> ahappychild.txt &gt; ahappychild2.txt</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055318u6w915x3w6gg64l5.png" alt="sed 命令样例"></p>
<p><em>sed 命令样例</em></p>
<p>如果你要在替换文本中搜索或者替换特殊字符（如 /，\，＆），你需要使用反斜杠对它进行转义。</p>
<p>例如，我们要用一个符号来替换一个文字，与此同时我们将把一行最开始出现的第一个 I 替换为 You。</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed <span class="symbol">'s</span>/<span class="keyword">and</span>/\&amp;/g;s/^<span class="type">I</span>/<span class="type">You</span>/g' ahappychild.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055318ustph1gt8asgs2t8.png" alt="sed 替换字符串"></p>
<p><em>sed 替换字符串</em></p>
<p>在上面的命令中，众所周知 ^（插入符号）是正则表达式中用来表示一行开头的符号。</p>
<p>正如你所看到的，我们可以通过使用分号分隔以及用括号包裹来把两个或者更多的替换命令（并在它们中使用正则表达式）连接起来。</p>
<p>另一种 sed 的用法是显示或者删除文件中选中的一部分。在下面的样例中，将会显示 /var/log/messages 中从6月8日开始的头五行。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sed -<span class="keyword">n</span> '/^Jun  8/ p' /<span class="keyword">var</span>/<span class="keyword">log</span>/messages | sed -<span class="keyword">n</span> 1,5p</span><br></pre></td></tr></table></figure>
<p>请注意，在默认的情况下，sed 会打印每一行。我们可以使用 -n 选项来覆盖这一行为并且告诉 sed 只需要打印（用 p来表示）文件（或管道）中匹配的部分（第一个命令中指定以“Jun 8” 开头的行，第二个命令中指定一到五行）。</p>
<p>最后，可能有用的技巧是当检查脚本或者配置文件的时候可以保留文件本身并且删除注释。下面的单行 sed 命令删除（d）空行或者是开头为<code>#</code>的行（| 字符对两个正则表达式进行布尔 OR 操作）。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># sed <span class="string">'/^#\|^$/d'</span> apache2.conf</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055318sz9c1jpnjqnacl1p.png" alt="sed 匹配字符串"></p>
<p><em>sed 匹配字符串</em></p>
<h4 id="uniq-命令"><a href="#uniq-命令" class="headerlink" title="uniq 命令"></a>uniq 命令</h4><p>uniq 命令允许我们返回或者删除文件中重复的行，默认写到标准输出。我们必须注意到，除非两个重复的行相邻，否则uniq 命令不会删除他们。因此，uniq 经常和一个前置的 sort 命令（一种用来对文本行进行排序的算法）搭配使用。默认情况下，sort 使用第一个字段（用空格分隔）作为关键字段。要指定一个不同的关键字段，我们需要使用 -k 选项。</p>
<p><strong>样例</strong></p>
<p>du –sch /path/to/directory/* 命令将会以人类可读的格式返回在指定目录下每一个子文件夹和文件的磁盘空间使用情况（也会显示每个目录总体的情况），而且不是按照大小输出，而是按照子文件夹和文件的名称。我们可以使用下面的命令来让它通过大小排序。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># du -sch <span class="regexp">/var/</span>* | <span class="keyword">sort</span> -h</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055319qckggebd272dhhe2.jpg" alt="sort 命令样例"></p>
<p><em>sort 命令样例</em></p>
<p>你可以通过使用下面的命令告诉 uniq 比较每一行的前6个字符（-w 6）（这里是指定的日期）来统计日志事件的个数，而且在每一行的开头输出出现的次数（-c）。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">cat</span> /<span class="keyword">var</span>/<span class="keyword">log</span>/mail.<span class="keyword">log</span> | uniq -c -w 6</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055319ex1ex1hxjmnywnbm.jpg" alt="文件中的统计数字"></p>
<p><em>文件中的统计数字</em></p>
<p>最后，你可以组合使用 sort 和 uniq 命令（通常如此）。看看下面文件中捐助者、捐助日期和金额的列表。假设我们想知道有多少个捐助者。我们可以使用下面的命令来分隔第一字段（字段由冒号分隔），按名称排序并且删除重复的行。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">cat</span> sortuniq.txt | cut -<span class="keyword">d</span>: -f1 | <span class="keyword">sort</span> | uniq</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055320quba70a7m8vbe4ym.jpg" alt="寻找文件中不重复的记录"></p>
<p><em>寻找文件中不重复的记录</em></p>
<ul>
<li>也可阅读: <a href="https://linux.cn/article-2336-1.html" target="_blank" rel="external">13个“cat”命令样例</a></li>
</ul>
<h4 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h4><p>grep 在文件（或命令输出）中搜索指定正则表达式，并且在标准输出中输出匹配的行。</p>
<p><strong>样例</strong></p>
<p>显示文件 /etc/passwd 中用户 gacanepa 的信息，忽略大小写。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">grep</span> -i gacanepa <span class="regexp">/etc/</span>passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055320eepm9mp9mm4qwe9e.jpg" alt="grep 命令样例"></p>
<p><em>grep 命令样例</em></p>
<p>显示 /etc 文件夹下所有 rc 开头并跟随任意数字的内容。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">ls</span> -<span class="keyword">l</span> /etc | grep rc[0-9]</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055321o4y33j3zzk3k4jpk.jpg" alt="使用 grep 列出内容"></p>
<p><em>使用 grep 列出内容</em></p>
<ul>
<li>也可阅读: <a href="https://linux.cn/article-2250-1.html" target="_blank" rel="external">12个“grep”命令样例</a></li>
</ul>
<h4 id="tr-命令使用技巧"><a href="#tr-命令使用技巧" class="headerlink" title="tr 命令使用技巧"></a>tr 命令使用技巧</h4><p>tr 命令可以用来从标准输入中转换（改变）或者删除字符，并将结果写入到标准输出中。</p>
<p><strong>样例</strong></p>
<p>把 sortuniq.txt 文件中所有的小写改为大写。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat sortuniq.txt | tr <span class="string">[:lower:]</span> <span class="string">[:upper:]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055321tjh2huac2yxxhx29.jpg" alt="排序文件中的字符串"></p>
<p><em>排序文件中的字符串</em></p>
<p>压缩<code>ls –l</code>输出中的分隔符为一个空格。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">ls</span> -<span class="keyword">l</span> | <span class="keyword">tr</span> -s <span class="string">' '</span></span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055321hz2w9e42egucz2iu.jpg" alt="压缩分隔符"></p>
<p><em>压缩分隔符</em></p>
<h4 id="cut-命令使用方法"><a href="#cut-命令使用方法" class="headerlink" title="cut 命令使用方法"></a>cut 命令使用方法</h4><p>cut 命令可以基于字节（-b选项）、字符（-c）或者字段（-f）提取部分输入（从标准输入或者文件中）并且将结果输出到标准输出。在最后一种情况下（基于字段），默认的字段分隔符是一个制表符，但可以由 -d 选项来指定不同的分隔符。</p>
<p><strong>样例</strong></p>
<p>从 /etc/passwd 中提取用户账户和他们被分配的默认 shell（-d 选项允许我们指定分界符，-f 选项指定那些字段将被提取）。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">cat</span> /etc/passwd | cut -<span class="keyword">d</span>: -f1,7</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055322pgyrzp6irfm299fj.jpg" alt="提取用户账户"></p>
<p><em>提取用户账户</em></p>
<p>将以上命令结合起来，我们将使用 last 命令的输出中第一和第三个非空文件创建一个文本流。我们将使用 grep 作为第一过滤器来检查用户 gacanepa 的会话，然后将分隔符压缩至一个空格（tr -s ‘ ‘)。下一步，我们将使用 cut 来提取第一和第三个字段，最后使用第二个字段（本样例中，指的是IP地址）来排序之后，再用 uniq 去重。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">last</span> | <span class="keyword">grep</span> gacanepa | <span class="keyword">tr</span> -s ‘ ‘ | cut -d’ ‘ -f1,<span class="number">3</span> | <span class="keyword">sort</span> -k2 | uniq</span><br></pre></td></tr></table></figure>
<p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201603/28/055322bio7q6dxhoioeo6q.png" alt="last 命令样例"></p>
<p><em>last 命令样例</em></p>
<p>上面的命令显示了如何将多个命令和管道结合起来，以便根据我们的要求得到过滤后的数据。你也可以逐步地使用它以帮助你理解输出是如何从一个命令传输到下一个命令的（顺便说一句，这是一个非常好的学习经验！）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[方向选择和埋头苦干]]></title>
      <url>http://qiankun.space/2016/05/20/orientation-is-more-important-than-hardwork/</url>
      <content type="html"><![CDATA[<p>勤奋努力是一个人的优良品质，对于这一点我深信不疑。可是如果就一件事、一个结果而言，选择“方向”的重要性就显得格外突出。</p>
<p>近一段时间尝试在系统中实现一个显示备份还原百分比的功能，自己想了好多种办法，然后从中择取一个自己比较满意的方案。为了实现该功能我老老实实地坐工位上调试了将近两天，快要完成的时候我将写的代码邮件给老大进行查看，没想到老大提出了一种通过添加一个参数就可以直接获取百分比的方案，我按照该方案实施了一遍，确实要比我原有的方案要简单，而且获取的百分比数据也比我自己通过代码计算出来的要准确。尽管在自己实现该功能的过程中我不断地调试代码有助于我学习及巩固相关知识，但是对于实现该功能这个结果来说，我做了太多的无用功。一个方案的变化，一次思考角度的转化都是选择“方向”的具体体现。</p>
<p>生活是一个体验的过程，但是体验一个什么样的生活状态就是一个比较具体的结果，也是我们每个人所奋斗的方向。我常听到一句这样的话“怎么忙不重要，忙什么才重要”，南辕北辙、缘木求鱼等类似的行为在生活中并不少见，忙忙碌碌的人群中又有几人真正知道自己所奋斗的生活方向？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[马后炮]]></title>
      <url>http://qiankun.space/2016/05/13/monday-morning-quarterback/</url>
      <content type="html"><![CDATA[<p>“马后炮”常用来比喻不及时的举动，贬义。如果要是用来形容某个人的话至少能充分表达鄙夷的态度。可是如今我却越来却喜欢这个词了，而且我希望人们都能向“马后炮”的方向靠拢。</p>
<p>以前信息传播的比较慢，当你获取到某个信息时围绕这个信息的相关事情都已经差不多明晰，稍加思考便可以推断出结果，此时如果需要自己采取有一些提前量的措施或表态而没有及时去做当然会被大家鄙视为没脑子的行为；可如今时代变了，信息量如此之大、传播如此迅速等都是以前没有的，如果风闻一件事情并且立马采取措施或表态，我认为是不负责任的，是没过脑子的行为，不可取。</p>
<p>在信息传播方式如此便捷的今天，提供更加准确的信息尤为重要。可如今我根本看不到这一点，媒体为了吸引大众的视线，在信息未经考证的情况下就发布了，更有甚者为了迎合大众的心理不惜对信息添油加醋、歪曲事实，然后再将围绕信息的相关状况一点一点进行披露以达到长时间消费该信息的目的。</p>
<p>其实我对于媒体的态度还是比较复杂的。毕竟以前下面发生什么事情根本传不乡镇，好多冤情也得不到伸张，如今有媒体介入这种状况会改善很多，可在彰显媒体力量的同时部分媒体却又没能恪守媒道德底线混淆视听哗众取宠。媒体的发展需要时间，我只希望越来越健全的法制能够更好地约束他们的行为。但对于个人而言没有一个明辨是非的能力，听风就是雨任人摆布而且以讹传讹更不能让我接受。</p>
<p>我承认如今的社会矛盾很尖锐，也能感受到政府公信力的丧失，可我不愿人们都失去理智被一个又一个媒体添加标签后所谓的“事件”左右，而是自己去思考一下，然后给“事件”打上属于自己的标签。</p>
<p>社会风气是浮躁的，做一个“马后炮”给自己更多的时间思考。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅析Linux初始化init系统]]></title>
      <url>http://qiankun.space/2016/05/10/introduce-the-linux-system-init/</url>
      <content type="html"><![CDATA[<h3 id="什么是-Init-系统-init-系统的历史和现状"><a href="#什么是-Init-系统-init-系统的历史和现状" class="headerlink" title="什么是 Init 系统,init 系统的历史和现状"></a>什么是 Init 系统,init 系统的历史和现状</h3><p>Linux 操作系统的启动首先从 BIOS 开始，接下来进入 bootloader，由 bootloader 载入内核，进行内核初始化。内核初始化的最后一步就是启动 pid 为 1 的 init 进程。这个进程是系统的第一个进程。它负责产生其他所有用户进程。</p>
<p>init 以守护进程方式存在，是所有其他进程的祖先。init 进程非常独特，能够完成其他进程无法完成的任务。</p>
<p>Init 系统能够定义、管理和控制 init 进程的行为。它负责组织和运行许多独立的或相关的始化工作(因此被称为 init 系统)，从而让计算机系统进入某种用户预订的运行模式。</p>
<p>仅仅将内核运行起来是毫无实际用途的，必须由 init 系统将系统代入可操作状态。比如启动外壳 shell 后，便有了人机交互，这样就可以让计算机执行一些预订程序完成有实际意义的任务。或者启动 X 图形系统以便提供更佳的人机界面，更加高效的完成任务。这里，字符界面的 shell 或者 X 系统都是一种预设的运行模式。</p>
<p>大多数 Linux 发行版的 init 系统是和 System V 相兼容的，被称为 sysvinit。这是人们最熟悉的 init 系统。一些发行版如 Slackware 采用的是 BSD 风格 Init 系统，这种风格使用较少，本文不再涉及。其他的发行版如 Gentoo 是自己定制的。Ubuntu 和 RHEL 采用 upstart 替代了传统的 sysvinit。而 Fedora 从版本 15 开始使用了一个被称为 systemd 的新 init 系统。</p>
<p>可以看到不同的发行版采用了不同的 init 实现，本系列文章就是打算讲述三个主要的 Init 系统：sysvinit，UpStart 和 systemd。了解它们各自的设计特点，并简要介绍它们的使用。</p>
<p>在 Linux 主要应用于服务器和 PC 机的时代，SysVinit 运行非常良好，概念简单清晰。它主要依赖于 Shell 脚本，这就决定了它的<strong>最大弱点：启动太慢</strong>。在很少重新启动的 Server 上，这个缺点并不重要。而当 Linux 被应用到移动终端设备的时候，启动慢就成了一个大问题。为了更快地启动，人们开始改进 sysvinit，先后出现了 upstart 和 systemd 这两个主要的新一代 init 系统。Upstart 已经开发了 8 年多，在不少系统中已经替换 sysvinit。Systemd 出现较晚，但发展更快，大有取代 upstart 的趋势。</p>
<h3 id="Sysvinit-概况"><a href="#Sysvinit-概况" class="headerlink" title="Sysvinit 概况"></a>Sysvinit 概况</h3><p>Sysvinit 就是 system V 风格的 init 系统，顾名思义，它源于 System V 系列 UNIX。它提供了比 BSD 风格 init 系统更高的灵活性。是已经风行了几十年的 UNIX init 系统，一直被各类 Linux 发行版所采用。</p>
<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Sysvinit 用术语 runlevel 来定义”预订的运行模式”。Sysvinit 检查 ‘/etc/inittab’ 文件中是否含有 ‘initdefault’ 项。 这告诉 init 系统是否有一个默认运行模式。如果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。</p>
<p>sysvinit 中运行模式描述了系统各种预订的运行模式。通常会有 8 种运行模式，即运行模式 0 到 6 和 S 或者 s。</p>
<p>每种 Linux 发行版对运行模式的定义都不太一样。但 0，1，6 却得到了大家的一致赞同：</p>
<ul>
<li>0 关机</li>
<li>1 单用户模式</li>
<li>6 重启</li>
</ul>
<p>通常在 /etc/inittab 文件中定义了各种运行模式的工作范围。比如 RedHat 定义了 runlevel 3 和 5。运行模式 3 将系统初始化为字符界面的 shell 模式；运行模式 5 将系统初始化为 GUI 模式。无论是命令行界面还是 GUI，运行模式 3 和 5 相对于其他运行模式而言都是完整的正式的运行状态，计算机可以完成用户需要的任务。而模式 1，S 等往往用于系统故障之后的排错和恢复。</p>
<p>很显然，这些不同的运行模式下系统需要初始化运行的进程和需要进行的初始化准备都是不同的。比如运行模式 3 不需要启动 X 系统。用户只需要指定需要进入哪种模式，sysvinit 将负责执行所有该模式所必须的初始化工作。</p>
<h3 id="sysvinit-运行顺序"><a href="#sysvinit-运行顺序" class="headerlink" title="sysvinit 运行顺序"></a>sysvinit 运行顺序</h3><p>Sysvinit 巧妙地用脚本，文件命名规则和软链接来实现不同的 runlevel。首先，sysvinit 需要读取/etc/inittab 文件。分析这个文件的内容，它获得以下一些配置信息：</p>
<ul>
<li>系统需要进入的 runlevel</li>
<li>捕获组合键的定义</li>
<li>定义电源 fail/restore 脚本</li>
<li>启动 getty 和虚拟控制台</li>
</ul>
<p>得到配置信息后，sysvinit 顺序地执行以下这些步骤，从而将系统初始化为预订的 runlevel X。</p>
<ul>
<li>/etc/rc.d/rc.sysinit</li>
<li>/etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6)</li>
<li>/etc/rc.d/rc.local</li>
<li>X Display Manager（如果需要的话）</li>
</ul>
<p>首先，运行 rc.sysinit 以便执行一些重要的系统初始化任务。在 RedHat 公司的 RHEL5 中(RHEL6 已经使用 upstart 了)，rc.sysinit 主要完成以下这些工作。</p>
<ul>
<li>激活 udev 和 selinux</li>
<li>设置定义在/etc/sysctl.conf 中的内核参数</li>
<li>设置系统时钟</li>
<li>加载 keymaps</li>
<li>使能交换分区</li>
<li>设置主机名(hostname)</li>
<li>根分区检查和 remount</li>
<li>激活 RAID 和 LVM 设备</li>
<li>开启磁盘配额</li>
<li>检查并挂载所有文件系统</li>
<li>清除过期的 locks 和 PID 文件</li>
</ul>
<p>完成了以上这些工作之后，sysvinit 开始运行/etc/rc.d/rc 脚本。根据不同的 runlevel，rc 脚本将打开对应该 runlevel 的 rcX.d 目录(X 就是 runlevel)，找到并运行存放在该目录下的所有启动脚本。每个 runlevel X 都有一个这样的目录，目录名为/etc/rc.d/rcX.d。</p>
<p>在这些目录下存放着很多不同的脚本。文件名以 S 开头的脚本就是启动时应该运行的脚本，S 后面跟的数字定义了这些脚本的执行顺序。在/etc/rc.d/rcX.d 目录下的脚本其实都是一些软链接文件，真实的脚本文件存放在/etc/init.d 目录下。如下所示：</p>
<h4 id="rc5-d-目录下的脚本"><a href="#rc5-d-目录下的脚本" class="headerlink" title="rc5.d 目录下的脚本"></a>rc5.d 目录下的脚本</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# ll /etc/rc5.d/</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 16 Sep 4 2008 K02dhcdbd -&gt;</span> ../init.d/dhcdbd</span><br><span class="line">....(中间省略)....</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 14 Sep 4 2008 K91capi -&gt;</span> ../init.d/capi</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 23 Sep 4 2008 S00microcode_ctl -&gt;</span> ../init.d/microcode_ctl</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 22 Sep 4 2008 S02lvm2-monitor -&gt;</span> ../init.d/lvm2-monitor</span><br><span class="line">....(中间省略)....</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 17 Sep 4 2008 S10network -&gt;</span> ../init.d/network</span><br><span class="line">....(中间省略)....</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 11 Sep 4 2008 S99local -&gt;</span> ../rc.local</span><br><span class="line"><span class="function"><span class="title">lrwxrwxrwx</span> 1 root root 16 Sep 4 2008 S99smartd -&gt;</span> ../init.d/smartd</span><br><span class="line">....(底下省略)....</span><br></pre></td></tr></table></figure>
<p>当所有的初始化脚本执行完毕。Sysvinit 运行/etc/rc.d/rc.local 脚本。</p>
<p>rc.local 是 Linux 留给用户进行个性化设置的地方。您可以把自己私人想设置和启动的东西放到这里，一台 Linux Server 的用户一般不止一个，所以才有这样的考虑。</p>
<h3 id="Sysvinit-和系统关闭"><a href="#Sysvinit-和系统关闭" class="headerlink" title="Sysvinit 和系统关闭"></a>Sysvinit 和系统关闭</h3><p>Sysvinit 不仅需要负责初始化系统，还需要负责关闭系统。在系统关闭时，为了保证数据的一致性，需要小心地按顺序进行结束和清理工作。</p>
<p>比如应该先停止对文件系统有读写操作的服务，然后再 umount 文件系统。否则数据就会丢失。</p>
<p>这种顺序的控制这也是依靠/etc/rc.d/rcX.d/目录下所有脚本的命名规则来控制的，在该目录下所有以 K 开头的脚本都将在关闭系统时调用，字母 K 之后的数字定义了它们的执行顺序。</p>
<p>这些脚本负责安全地停止服务或者其他的关闭工作。</p>
<h3 id="Sysvinit-的管理和控制功能"><a href="#Sysvinit-的管理和控制功能" class="headerlink" title="Sysvinit 的管理和控制功能"></a>Sysvinit 的管理和控制功能</h3><p>此外，在系统启动之后，管理员还需要对已经启动的进程进行管理和控制。原始的 sysvinit 软件包包含了一系列的控制启动，运行和关闭所有其他程序的工具。<br><strong> halt </strong><br>停止系统。<br><strong> init </strong><br>这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。<br><strong> killall5 </strong><br>就是 SystemV 的 killall 命令。向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。<br><strong> last </strong><br>回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。<br><strong> lastb </strong><br>作用和 last 差不多，默认情况下使用/var/log/btmp 文件，显示所有失败登录企图。<br><strong> mesg </strong><br>控制其它用户对用户终端的访问。<br><strong> pidof </strong><br>找出程序的进程识别号(pid)，输出到标准输出设备。<br><strong> poweroff </strong><br>等于 shutdown -h –p，或者 telinit 0。关闭系统并切断电源。<br><strong> reboot </strong><br>等于 shutdown –r 或者 telinit 6。重启系统。<br><strong> runlevel </strong><br>读取系统的登录记录文件(一般是/var/run/utmp)把以前和当前的系统运行级输出到标准输出设备。<br><strong> shutdown </strong><br>以一种安全的方式终止系统，所有正在登录的用户都会收到系统将要终止通知，并且不准新的登录。<br><strong> sulogin </strong><br>当系统进入单用户模式时，被 init 调用。当接收到启动加载程序传递的-b 选项时，init 也会调用 sulogin。<br><strong> telinit </strong><br>实际是 init 的一个连接，用来向 init 传送单字符参数和信号。<br><strong> utmpdump </strong><br>以一种用户友好的格式向标准输出设备显示/var/run/utmp 文件的内容。<br><strong> wall </strong><br>向所有有信息权限的登录用户发送消息。</p>
<p>不同的 Linux 发行版在这些 sysvinit 的基本工具基础上又开发了一些辅助工具用来简化 init 系统的管理工作。比如 RedHat 的 RHEL 在 sysvinit 的基础上开发了 initscripts 软件包，包含了大量的启动脚本 (如 rc.sysinit) ，还提供了 service，chkconfig 等命令行工具，甚至一套图形化界面来管理 init 系统。其他的 Linux 发行版也有各自的 initscript 或其他名字的 init 软件包来简化 sysvinit 的管理。</p>
<p>只要您理解了 sysvinit 的机制，在一个最简的仅有 sysvinit 的系统下，您也可以直接调用脚本启动和停止服务，手动创建 inittab 和创建软连接来完成这些任务。因此理解 sysvinit 的基本原理和命令是最重要的。您甚至也可以开发自己的一套管理工具。</p>
<h3 id="Sysvinit-的小结"><a href="#Sysvinit-的小结" class="headerlink" title="Sysvinit 的小结"></a>Sysvinit 的小结</h3><p>Sysvinit 的优点是概念简单。Service 开发人员只需要编写启动和停止脚本，概念非常清楚；将 service 添加/删除到某个 runlevel 时，只需要执行一些创建/删除软连接文件的基本操作；这些都不需要学习额外的知识或特殊的定义语法(UpStart 和 Systemd 都需要用户学习新的定义系统初始化行为的语言)。</p>
<p>其次，sysvinit 的另一个重要优点是确定的执行顺序：脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查。UpStart 和 systemd 支持并发启动，导致没有人可以确定地了解具体的启动顺序，排错不易。</p>
<p>但是串行地执行脚本导致 sysvinit 运行效率较慢，在新的 IT 环境下，启动快慢成为一个重要问题。此外动态设备加载等 Linux 新特性也暴露出 sysvinit 设计的一些问题。针对这些问题，人们开始想办法改进 sysvinit，以便加快启动时间，并解决 sysvinit 自身的设计问题。</p>
<hr>
<h3 id="Upstart-简介"><a href="#Upstart-简介" class="headerlink" title="Upstart 简介"></a>Upstart 简介</h3><p>假如您使用的 Linux 发行版是 Ubuntu，很可能会发现在您的计算机上找不到/etc/inittab 文件了，这是因为 Ubuntu 使用了一种被称为 upstart 的新型 init 系统。</p>
<h3 id="开发-Upstart-的缘由"><a href="#开发-Upstart-的缘由" class="headerlink" title="开发 Upstart 的缘由"></a>开发 Upstart 的缘由</h3><p>大约在 2006 年或者更早的时候， Ubuntu 开发人员试图将 Linux 安装在笔记本电脑上。在这期间技术人员发现经典的 sysvinit 存在一些问题：它不适合笔记本环境。这促使程序员 Scott James Remnant 着手开发 upstart。</p>
<p>当 Linux 内核进入 2.6 时代时，内核功能有了很多新的更新。新特性使得 Linux 不仅是一款优秀的服务器操作系统，也可以被用于桌面系统，甚至嵌入式设备。桌面系统或便携式设备的一个特点是经常重启，而且要频繁地使用硬件热插拔技术。 在现代计算机系统中，硬件繁多、接口有限，人们并非将所有设备都始终连接在计算机上，比如 U 盘平时并不连接电脑，使用时才插入 USB 插口。因此，当系统上电启动时，一些外设可能并没有连接。而是在启动后当需要的时候才连接这些设备。在 2.6 内核支持下，一旦新外设连接到系统，内核便可以自动实时地发现它们，并初始化这些设备，进而使用它们。这为便携式设备用户提供了很大的灵活性。</p>
<p>可是这些特性为 sysvinit 带来了一些挑战。当系统初始化时，需要被初始化的设备并没有连接到系统上；比如打印机。为了管理打印任务，系统需要启动 CUPS 等服务，而如果打印机没有接入系统的情况下，启动这些服务就是一种浪费。Sysvinit 没有办法处理这类需求，它必须一次性把所有可能用到的服务都启动起来，即使打印机并没有连接到系统，CUPS 服务也必须启动。</p>
<p>还有网络共 享盘的挂载问题。在/etc/fstab 中，可以指定系统自动挂载一个网络盘，比如 NFS，或者 iSCSI 设备。在本文的第一部分 sysvinit 的简介中可以看到，sysvinit 分析/etc/fstab 挂载文件系统这个步骤是在网络启动之前。可是如果网络没有启动，NFS 或者 iSCSI 都不可访问，当然也无法进行挂载操作。Sysvinit 采用 netdev 的方式来解决这个问题，即/etc/fstab 发现 netdev 属性挂载点的时候，不尝试挂载它，在网络初始化并使能之后，还有一个专门的 netfs 服务来挂载所有这些网络盘。这是一个不得已的补救方法，给管理员带来不便。部分新手管理员甚至从来也没有听说过 netdev 选项，因此经常成为系统管理的一个陷阱。</p>
<p>针对以上种种情况，Ubuntu 开发人员在评估了当时的几个可选 init 系统之后，决定重新设计和开发一个全新的 init 系统，即 UpStart。UpStart 基于事件机制，比如 U 盘插入 USB 接口后，udev 得到内核通知，发现该设备，这就是一个新的事件。UpStart 在感知到该事件之后触发相应的等待任务，比如处理/etc/fstab 中存在的挂载点。采用这种事件驱动的模式，upstart 完美地解决了即插即用设备带来的新问题。</p>
<p>此外，采用事件驱动机制也带来了一些其它有益的变化，比如加快了系统启动时间。sysvinit 运行时是同步阻塞的。一个脚本运行的时候，后续脚本必须等待。这意味着所有的初始化步骤都是串行执行的，而实际上很多服务彼此并不相关，完全可以并行启 动，从而减小系统的启动时间。在 Linux 大量应用于服务器的时代，系统启动时间也许还不那么重要；然而对于桌面系统和便携式设备，启动时间的长短对用户体验影响很大。此外云计算等新的 Server 端技术也往往需要单个设备可以更加快速地启动。</p>
<p>UpStart 满足了这些需求，目前不仅桌面系统 Ubuntu 采用了 UpStart，甚至企业级服务器级的 RHEL 也默认采用 UpStart 来替换 sysvinit 作为 init 系统。</p>
<h3 id="Upstart-的特点"><a href="#Upstart-的特点" class="headerlink" title="Upstart 的特点"></a>Upstart 的特点</h3><p>UpStart 解决了之前提到的 sysvinit 的缺点。采用事件驱动模型，UpStart 可以：</p>
<ul>
<li>更快地启动系统</li>
<li>当新硬件被发现时动态启动服务</li>
<li>硬件被拔除时动态停止服务</li>
</ul>
<p>这些特点使得 UpStart 可以很好地应用在桌面或者便携式系统中，处理这些系统中的动态硬件插拔特性。</p>
<h3 id="Upstart-概念和术语"><a href="#Upstart-概念和术语" class="headerlink" title="Upstart 概念和术语"></a>Upstart 概念和术语</h3><p>Upstart 的基本概念和设计清晰明确。UpStart 主要的概念是 job 和 event。Job 就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个 Job 都等待一个或多个事件，一旦事件发生，upstart 就触发该 job 完成相应的工作。</p>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>Job 就是一个工作的单元，一个任务或者一个服务。可以理解为 sysvinit 中的一个服务脚本。有三种类型的工作：</p>
<ul>
<li>task job；</li>
<li>service job；</li>
<li>abstract job；</li>
</ul>
<p>task job 代表在一定时间内会执行完毕的任务，比如删除一个文件；</p>
<p>service job 代表后台服务进程，比如 apache httpd。这里进程一般不会退出，一旦开始运行就成为一个后台精灵进程，由 init 进程管理，如果这类进程退出，由 init 进程重新启动，它们只能由 init 进程发送信号停止。它们的停止一般也是由于所依赖的停止事件而触发的，不过 upstart 也提供命令行工具，让管理人员手动停止某个服务；</p>
<p>Abstract job 仅由 upstart 内部使用，仅对理解 upstart 内部机理有所帮助。我们不用关心它。</p>
<p>除了以上的分类之外，还有另一种工作（Job）分类方法。Upstart 不仅可以用来为整个系统的初始化服务，也可以为每个用户会话（session）的初始化服务。系统的初始化任务就叫做 system job，比如挂载文件系统的任务就是一个 system job；用户会话的初始化服务就叫做 session job。</p>
<h4 id="Job-生命周期"><a href="#Job-生命周期" class="headerlink" title="Job 生命周期"></a>Job 生命周期</h4><p>Upstart 为每个工作都维护一个生命周期。一般来说，工作有开始，运行和结束这几种状态。为了更精细地描述工作的变化，Upstart 还引入了一些其它的状态。比如开始就有开始之前(pre-start)，即将开始(starting)和已经开始了(started)几种不同的状态，这 样可以更加精确地描述工作的当前状态。</p>
<p>工作从某种初始状态开始，逐渐变化，或许要经历其它几种不同的状态，最终进入另外一种状态，形成一个状态机。在这个过程中，当工作的状态即将发生变化的时候，init 进程会发出相应的事件（event）。</p>
<p>表 1.Upstart 中 Job 的可能状态</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Waiting</td>
<td>初始状态</td>
</tr>
<tr>
<td>Starting</td>
<td>Job 即将开始</td>
</tr>
<tr>
<td>pre-start</td>
<td>执行 pre-start 段，即任务开始前应该完成的工作</td>
</tr>
<tr>
<td>Spawned</td>
<td>准备执行 script 或者 exec 段</td>
</tr>
<tr>
<td>post-start</td>
<td>执行 post-start 动作</td>
</tr>
<tr>
<td>Running</td>
<td>interim state set after post-start section processed denoting job is running (But it may have no associated PID!)</td>
</tr>
<tr>
<td>pre-stop</td>
<td>执行 pre-stop 段</td>
</tr>
<tr>
<td>Stopping</td>
<td>interim state set after pre-stop section processed</td>
</tr>
<tr>
<td>Killed</td>
<td>任务即将被停止</td>
</tr>
<tr>
<td>post-stop</td>
<td>执行 post-stop 段</td>
</tr>
</tbody>
</table>
<p>下图展示了 Job 的状态机。</p>
<p>Job’s life cycle</p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/image003.jpg" alt=""></p>
<p>其中有四个状态会引起 init 进程发送相应的事件，表明该工作的相应变化：</p>
<ul>
<li><p>Starting</p>
</li>
<li><p>Started</p>
</li>
<li><p>Stopping</p>
</li>
<li><p>Stopped</p>
</li>
</ul>
<p>而其它的状态变化不会发出事件。那么我们接下来就来看看事件的详细含义吧。</p>
<h4 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h4><p>顾名思义，Event 就是一个事件。事件在 upstart 中以通知消息的形式具体存在。一旦某个事件发生了，Upstart 就向整个系统发送一个消息。没有任何手段阻止事件消息被 upstart 的其它部分知晓，也就是说，事件一旦发生，整个 upstart 系统中所有工作和其它的事件都会得到通知。</p>
<p>Event 可以分为三类: signal，methods 或者 hooks。</p>
<p><strong> Signals </strong><br>Signal 事件是非阻塞的，异步的。发送一个信号之后控制权立即返回。</p>
<p><strong> Methods </strong><br>Methods 事件是阻塞的，同步的。</p>
<p><strong> Hooks </strong><br>Hooks 事件是阻塞的，同步的。它介于 Signals 和 Methods 之间，调用发出 Hooks 事件的进程必须等待事件完成才可以得到控制权，但不检查事件是否成功。</p>
<p>事件是个非常抽象的概念，下面我罗列出一些常见的事件，希望可以帮助您进一步了解事件的含义：</p>
<ul>
<li><p>系统上电启动，init 进程会发送”start”事件</p>
</li>
<li><p>根文件系统可写时，相应 job 会发送文件系统就绪的事件</p>
</li>
<li><p>一个块设备被发现并初始化完成，发送相应的事件</p>
</li>
<li><p>某个文件系统被挂载，发送相应的事件</p>
</li>
<li><p>类似 atd 和 cron，可以在某个时间点，或者周期的时间点发送事件</p>
</li>
<li><p>另外一个 job 开始或结束时，发送相应的事件</p>
</li>
<li><p>一个磁盘文件被修改时，可以发出相应的事件</p>
</li>
<li><p>一个网络设备被发现时，可以发出相应的事件</p>
</li>
<li><p>缺省路由被添加或删除时，可以发出相应的事件</p>
</li>
</ul>
<p>不同的 Linux 发行版对 upstart 有不同的定制和实现，实现和支持的事件也有所不同，可以用man 7 upstart-events来查看事件列表。</p>
<h4 id="Job-和-Event-的相互协作"><a href="#Job-和-Event-的相互协作" class="headerlink" title="Job 和 Event 的相互协作"></a>Job 和 Event 的相互协作</h4><p>Upstart 就是由事件触发工作运行的一个系统，每一个程序的运行都由其依赖的事件发生而触发的。</p>
<p>系统初始化的过程是在工作和事件的相互协作下完成的，可以大致描述如下：系统初始化时，init 进程开始运行，init 进程自身会发出不同的事件，这些最初的事件会触发一些工作运行。每个工作运行过程中会释放不同的事件，这些事件又将触发新的工作运行。如此反复，直到整个 系统正常运行起来。</p>
<p>究竟哪些事件会触发某个工作的运行？这是由工作配置文件定义的。</p>
<h4 id="工作配置文件"><a href="#工作配置文件" class="headerlink" title="工作配置文件"></a>工作配置文件</h4><p>任何一个工作都是由一个工作配置文件（Job Configuration File）定义的。这个文件是一个文本文件，包含一个或者多个小节（stanza）。每个小节是一个完整的定义模块，定义了工作的一个方面，比如 author 小节定义了工作的作者。工作配置文件存放在/etc/init 下面，是以.conf 作为文件后缀的文件。</p>
<h5 id="一个最简单的工作配置文件"><a href="#一个最简单的工作配置文件" class="headerlink" title="一个最简单的工作配置文件"></a>一个最简单的工作配置文件</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This is a simple demo of Job Configure file</span></span><br><span class="line"><span class="comment">#This line is comment, start with #</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Stanza 1, The author</span></span><br><span class="line">author “Liu Ming”</span><br><span class="line"></span><br><span class="line"><span class="comment">#Stanza 2, Description</span></span><br><span class="line">description “This <span class="keyword">job </span>only has author <span class="keyword">and </span>description, so no use, <span class="keyword">just </span>a demo”</span><br></pre></td></tr></table></figure>
<p>上面的例子不会产生任何作用，一个真正的工作配置文件会包含很多小节，其中比较重要的小节有以下几个：</p>
<p><strong> “expect” Stanza </strong></p>
<p>Upstart 除了负责系统的启动过程之外，和 SysVinit 一样，Upstart 还提供一系列的管理工具。当系统启动之后，管理员可能还需要进行维护和调整，比如启动或者停止某项系统服务。或者将系统切换到其它的工作状态，比如改变运 行级别。本文后续将详细介绍 Upstart 的管理工具的使用。</p>
<p>为了启动，停止，重启和查询某个系统服务。Upstart 需要跟踪该服务所对应的进程。比如 httpd 服务的进程 PID 为 1000。当用户需要查询 httpd 服务是否正常运行时，Upstart 就可以利用 ps 命令查询进程 1000，假如它还在正常运行，则表明服务正常。当用户需要停止 httpd 服务时，Upstart 就使用 kill 命令终止该进程。为此，Upstart 必须跟踪服务进程的进程号。</p>
<p>部分服务进程为了将自己变成后台精灵进程(daemon)， 会采用两次派生(fork)的技术，另外一些服务则不会这样做。假如一个服务派生了两次，那么 UpStart 必须采用第二个派生出来的进程号作为服务的 PID。但是，UpStart 本身无法判断服务进程是否会派生两次，为此在定义该服务的工作配置文件中必须写明 expect 小节，告诉 UpStart 进程是否会派生两次。</p>
<p>Expect 有两种，”expect fork”表示进程只会 fork 一次；”expect daemonize”表示进程会 fork 两次。</p>
<p><strong> “exec” Stanza 和”script” Stanza </strong></p>
<p>一个 UpStart 工作一定需要做些什么，可能是运行一条 shell 命令，或者运行一段脚本。用”exec”关键字配置工作需要运行的命令；用”script”关键字定义需要运行的脚本。</p>
<h5 id="显示了-exec-和-script-的用法："><a href="#显示了-exec-和-script-的用法：" class="headerlink" title="显示了 exec 和 script 的用法："></a>显示了 exec 和 script 的用法：</h5><p>script 例子<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mountall.conf</span></span><br><span class="line">description “Mount filesystems <span class="keyword">on</span> boot”</span><br><span class="line">start <span class="keyword">on</span> startup</span><br><span class="line">stop <span class="keyword">on</span> starting rcS</span><br><span class="line">...</span><br><span class="line"><span class="keyword">script</span></span><br><span class="line">  . /etc/default/rcS</span><br><span class="line">  [ -f /forcefsck ] &amp;&amp; force_fsck=”<span class="comment">--force-fsck”</span></span><br><span class="line">  [ “$FSCKFIX”=”yes” ] &amp;&amp; fsck_fix=”<span class="comment">--fsck-fix”</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  exec mountall –daemon $force_fsck $fsck_fix</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">script</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这是 mountall 的例子，该工作在系统启动时运行，负责挂载所有的文件系统。该工作需要执行复杂的脚本，由”script”关键字定义；在脚本中，使用了 exec 来执行 mountall 命令。</p>
<p><strong> “start on” Stanza 和”stop on” Stanza </strong></p>
<p>“start on”定义了触发工作的所有事件。”start on”的语法很简单，如下所示：</p>
<p><code>start on EVENT [[KEY=]VALUE]... [and|or...]</code></p>
<p>EVENT 表示事件的名字，可以在 start on 中指定多个事件，表示该工作的开始需要依赖多个事件发生。多个事件之间可以用 and 或者 or 组合，”表示全部都必须发生”或者”其中之一发生即可”等不同的依赖条件。除了事件发生之外，工作的启动还可以依赖特定的条件，因此在 start on 的 EVENT 之后，可以用 KEY=VALUE 来表示额外的条件，一般是某个环境变量(KEY)和特定值(VALUE)进行比较。如果只有一个变量，或者变量的顺序已知，则 KEY 可以省略。</p>
<p>“stop on”和”start on”非常类似，只不过是定义工作在什么情况下需要停止。</p>
<h5 id="“start-on”和”stop-on”的一个例子。"><a href="#“start-on”和”stop-on”的一个例子。" class="headerlink" title="“start on”和”stop on”的一个例子。"></a>“start on”和”stop on”的一个例子。</h5><p>start on/ stop on 例子<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dbus.conf</span></span><br><span class="line">description     “D-Bus <span class="keyword">system</span> message bus”</span><br><span class="line"></span><br><span class="line"><span class="built_in">start</span> <span class="keyword">on</span> <span class="title">local-filesystems</span></span><br><span class="line"><span class="built_in">stop</span> <span class="keyword">on</span> <span class="title">deconfiguring-networking</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure></p>
<p>D-Bus 是一个系统消息服务，上面的配置文件表明当系统发出 local-filesystems 事件时启动 D-Bus；当系统发出 deconfiguring-networking 事件时，停止 D-Bus 服务。</p>
<h4 id="Session-Init"><a href="#Session-Init" class="headerlink" title="Session Init"></a>Session Init</h4><p>UpStart 还可以用于管理用户会话的初始化。在我写这篇文章的今天，多数 Linux 发行版还没有使用 UpStart 管理会话。只有在 Ubuntu Raring 版本中，使用 UpStart 管理用户会话的初始化过程。</p>
<p>首先让我们了解一下 Session 的概念。Session 就是一个用户会话，即用户从远程或者本地登入系统开始工作，直到用户退出。这整个过程就构成一个会话。</p>
<p>每个用户的使用习惯和使用方法都不相同，因此用户往往需要为自己的会话做一个定制，比如添加特定的命令别名，启动特殊的应用程序或者服务，等等。这些工作都属于对特定会话的初始化操作，因此可以被称为 Session Init。</p>
<p>用 户使用 Linux 可以有两种模式：字符模式和图形界面。在字符模式下，会话初始化相对简单。用户登录后只能启动一个 Shell，通过 shell 命令使用系统。各种 shell 程序都支持一个自动运行的启动脚本，比如~/.bashrc。用户在这些脚本中加入需要运行的定制化命令。字符会话需求简单，因此这种现有的机制工作的很 好。</p>
<p>在图形界面下，事情就变得复杂一些。用户登录后看到的并不是一个 shell 提示符，而是一个桌面。一个完整的桌面环境由很多组件组成。</p>
<p>一 个桌面环境包括 window manager，panel 以及其它一些定义在/usr/share/gnome-session/sessions/下面的基本组件；此外还有一些辅助的应用程序，共同帮助构成一 个完整的方便的桌面，比如 system monitors，panel applets，NetworkManager，Bluetooth，printers 等。当用户登录之后，这些组件都需要被初始化，这个过程比字符界面要复杂的多。目前启动各种图形组件和应用的工作由 gnome-session 完成。过程如下：</p>
<p>以 Ubuntu 为例，当用户登录 Ubuntu 图形界面后，显示管理器(Display Manager)lightDM 启动 Xsession。Xsession 接着启动 gnome-session，gnome-session 负责其它的初始化工作，然后就开始了一个 desktop session。</p>
<p>传统 desktop session 启动过程<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line"> |<span class="string">- lightdm</span><br><span class="line"> </span>|<span class="string">   </span>|<span class="string">- Xorg</span><br><span class="line"> </span>|<span class="string">   </span>|<span class="string">- lightdm ---session-child</span><br><span class="line"> </span>|<span class="string">        </span>|<span class="string">- gnome-session --session=ubuntu</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- compiz</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- gwibber</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- nautilus</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- nm-applet</span><br><span class="line"> </span>|<span class="string">             :</span><br><span class="line"> </span>|<span class="string">             :</span><br><span class="line"> </span>|</span><br><span class="line"> |<span class="string">- dbus-daemon --session</span><br><span class="line"> </span>|</span><br><span class="line"> :</span><br><span class="line"> :</span><br></pre></td></tr></table></figure></p>
<p>这个过程有一些缺点（和 sysVInit 类似）。一些应用和组件其实并不需要在会话初始化过程中启动，更好的选择是在需要它们的时候才启动。比如 update-notifier 服务，该服务不停地监测几个文件系统路径，一旦这些路径上发现可以更新的软件包，就提醒用户。这些文件系统路径包括新插入的 DVD 盘等。Update-notifier 由 gnome-session 启动并一直运行着，在多数情况下，用户并不会插入新的 DVD，此时 update-notifier 服务一直在后台运行并消耗系统资源。更好的模式是当用户插入 DVD 的时候再运行 update-notifier。这样可以加快启动时间，减小系统运行过程中的内存等系统资源的开销。对于移动，嵌入式等设备等这还意味着省电。除了 Update-notifier 服务之外，还有其它一些类似的服务。比如 Network Manager，一天之内用户很少切换网络设备，所以大部分时间 Network Manager 服务仅仅是在浪费系统资源；再比如 backup manager 等其它常驻内存，后台不间断运行却很少真正被使用的服务。</p>
<p>用 UpStart 的基于事件的按需启动的模式就可以很好地解决这些问题，比如用户插入网线的时候才启动 Network Manager，因为用户插入网线表明需要使用网络，这可以被称为按需启动。</p>
<p>下图描述了采用 UpStart 之后的会话初始化过程。</p>
<p>采用 Upstart 的 Desktop session init 过程<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init</span><br><span class="line"> |<span class="string">- lightdm</span><br><span class="line"> </span>|<span class="string">   </span>|<span class="string">- Xorg</span><br><span class="line"> </span>|<span class="string">   </span>|<span class="string">- lightdm ---session-child</span><br><span class="line"> </span>|<span class="string">        </span>|<span class="string">- session-init # &lt;-- upstart running as normal user</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- dbus-daemon --session</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- gnome-session --session=ubuntu</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- compiz</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- gwibber</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- nautilus</span><br><span class="line"> </span>|<span class="string">             </span>|<span class="string">- nm-applet</span><br><span class="line"> </span>|<span class="string">             :</span><br><span class="line"> </span>|<span class="string">             :</span><br><span class="line"> :</span><br><span class="line"> :</span></span><br></pre></td></tr></table></figure></p>
<h3 id="UpStart-使用"><a href="#UpStart-使用" class="headerlink" title="UpStart 使用"></a>UpStart 使用</h3><p>有两种人员需要了解 Upstart 的使用。第一类是系统开发人员，比如 MySQL 的开发人员。它们需要了解如何编写工作配置文件，以便用 UpStart 来管理服务。比如启动，停止 MySQL 服务。</p>
<p>另外一种情况是系统管理员，它们需要掌握 Upstart 的管理命令以便配置和管理系统的初始化，管理系统服务。</p>
<h4 id="系统开发人员需要了解的-UpStart-知识"><a href="#系统开发人员需要了解的-UpStart-知识" class="headerlink" title="系统开发人员需要了解的 UpStart 知识"></a>系统开发人员需要了解的 UpStart 知识</h4><p>系统开发人员不仅需要掌握工作配置文件的写法，还需要了解一些针对服务进程编程上的要求。本文仅列出了少数工作配置文件的语法。要全面掌握工作配置文件的写 法，需要详细阅读 Upstart 的手册。这里让我们来分析一下如何用 Upstart 来实现传统的运行级别，进而了解如何灵活使用工作配置文件。</p>
<p><strong> Upstart 系统中的运行级别 </strong></p>
<p>Upstart 的运作完全是基于工作和事件的。工作的状态变化和运行会引起事件，进而触发其它工作和事件。</p>
<p>而传统的 Linux 系统初始化是基于运行级别的，即 SysVInit。因为历史的原因，Linux 上的多数软件还是采用传统的 SysVInit 脚本启动方式，并没有为 UpStart 开发新的启动脚本，因此即便在 Debian 和 Ubuntu 系统上，还是必须模拟老的 SysVInit 的运行级别模式，以便和多数现有软件兼容。</p>
<p>虽然 Upstart 本身并没有运行级别的概念，但完全可以用 UpStart 的工作模拟出来。让我们完整地考察一下 UpStart 机制下的系统启动过程。</p>
<p><strong> 系统启动过程 </strong></p>
<p>下图描述了 UpStart 的启动过程。</p>
<p>UpStart 启动过程</p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/image004.png" alt=""></p>
<p>系统上电后运行 GRUB 载入内核。内核执行硬件初始化和内核自身初始化。在内核初始化的最后，内核将启动 pid 为 1 的 init 进程，即 UpStart 进程。</p>
<p>Upstart 进程在执行了一些自身的初始化工作后，立即发出”startup”事件。上图中用红色方框加红色箭头表示事件，可以在左上方看到”startup”事件。</p>
<p>所有依赖于”startup”事件的工作被触发，其中最重要的是 mountall。mountall 任务负责挂载系统中需要使用的文件系统，完成相应工作后，mountall 任务会发出以下事件：local-filesystem，virtual-filesystem，all-swaps，</p>
<p>其中 virtual-filesystem 事件触发 udev 任务开始工作。任务 udev 触发 upstart-udev-bridge 的工作。Upstart-udev-bridge 会发出 net-device-up IFACE=lo 事件，表示本地回环 IP 网络已经准备就绪。同时，任务 mountall 继续执行，最终会发出 filesystem 事件。</p>
<p>此时，任务 rc-sysinit 会被触发，因为 rc-sysinit 的 start on 条件如下：</p>
<p><code>start on filesystem and net-device-up IFACE=lo</code><br>任务 rc-sysinit 调用 telinit。Telinit 任务会发出 runlevel 事件，触发执行/etc/init/rc.conf。</p>
<p>rc.conf 执行/etc/rc$.d/目录下的所有脚本，和 SysVInit 非常类似，读者可以参考本文第一部分的描述。</p>
<p><strong> 程序开发时需要注意的事项 </strong></p>
<p>作为程序开发人员，在编写系统服务时，需要了解 UpStart 的一些特殊要求。只有符合这些要求的软件才可以被 UpStart 管理。</p>
<p><strong> 规则一，派生次数需声明。 </strong></p>
<p>很多 Linux 后台服务都通过派生两次的技巧将自己变成后台服务程序。如果您编写的服务也采用了这个技术，就必须通过文档或其它的某种方式明确地让 UpStart 的维护人员知道这一点，这将影响 UpStart 的 expect stanza，我们在前面已经详细介绍过这个 stanza 的含义。</p>
<p><strong> 规则二，派生后即可用。</strong></p>
<p>后台程序在完成第二次派生的时候，必须保证服务已经可用。因为 UpStart 通过派生计数来决定服务是否处于就绪状态。</p>
<p><strong> 规则三，遵守 SIGHUP 的要求。 </strong></p>
<p>UpStart 会给精灵进程发送 SIGHUP 信号，此时，UpStart 希望该精灵进程做以下这些响应工作：</p>
<ul>
<li><p>完成所有必要的重新初始化工作，比如重新读取配置文件。这是因为 UpStart 的命令”initctl reload”被设计为可以让服务在不重启的情况下更新配置。</p>
</li>
<li><p>精灵进程必须继续使用现有的 PID，即收到 SIGHUP 时不能调用 fork。如果服务必须在这里调用 fork，则等同于派生两次，参考上面的规则一的处理。这个规则保证了 UpStart 可以继续使用 PID 管理本服务。</p>
</li>
</ul>
<p><strong> 规则四，收到 SIGTEM 即 shutdown。 </strong></p>
<ul>
<li>当收到 SIGTERM 信号后，UpStart 希望精灵进程进程立即干净地退出，释放所有资源。如果一个进程在收到 SIGTERM 信号后不退出，Upstart 将对其发送 SIGKILL 信号。</li>
</ul>
<p><strong>系统管理员需要了解的 Upstart 命令 </strong></p>
<p>作为系统管理员，一个重要的职责就是管理系统服务。比如系统服务的监控，启动，停止和配置。UpStart 提供了一系列的命令来完成这些工作。其中的核心是initctl，这是一个带子命令风格的命令行工具。</p>
<p>比如可以用 initctl list 来查看所有工作的概况：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$initctl list</span><br><span class="line">alsa-mixer-save <span class="built_in">stop</span>/waiting</span><br><span class="line">avahi-daemon start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">690</span></span><br><span class="line">mountall-net <span class="built_in">stop</span>/waiting</span><br><span class="line">rc <span class="built_in">stop</span>/waiting</span><br><span class="line">rsyslog start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">482</span></span><br><span class="line">screen-cleanup <span class="built_in">stop</span>/waiting</span><br><span class="line">tty4 start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">859</span></span><br><span class="line">udev start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">334</span></span><br><span class="line">upstart-udev-bridge start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">304</span></span><br><span class="line">ureadahead-other <span class="built_in">stop</span>/waiting</span><br></pre></td></tr></table></figure></p>
<p>这是在 Ubuntu10.10 系统上的输出，其它的 Linux 发行版上的输出会有所不同。第一列是工作名，比如 rsyslog。第二列是工作的目标；第三列是工作的状态。</p>
<p>此外还可以用 initctl stop 停止一个正在运行的工作；用 initctl start 开始一个工作；还可以用 initctl status 来查看一个工作的状态；initctl restart 重启一个工作；initctl reload 可以让一个正在运行的服务重新载入配置文件。这些命令和传统的 service 命令十分相似。</p>
<p>service 命令和 initctl 命令对照表</p>
<table>
<thead>
<tr>
<th>Service 命令</th>
<th>UpStart initctl 命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>service start</td>
<td>initctl start</td>
</tr>
<tr>
<td>service stop</td>
<td>initctl stop</td>
</tr>
<tr>
<td>service restart</td>
<td>initctl restart</td>
</tr>
<tr>
<td>service reload</td>
<td>initctl reload</td>
</tr>
</tbody>
</table>
<p>很多情况下管理员并不喜欢子命令风格，因为需要手动键入的字符太多。UpStart 还提供了一些快捷命令来简化 initctl，实际上这些命令只是在内部调用相应的 initctl 命令。比如 reload，restart，start，stop 等等。启动一个服务可以简单地调用<br><code>start &lt;job&gt;</code><br>这和执行 <code>initctl start &lt;job&gt;</code> 是一样的效果。</p>
<p>一些命令是为了兼容其它系统(主要是 sysvinit)，比如显示 runlevel 用/sbin/runlevel 命令：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$runlevel</span></span></span><br><span class="line">N <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这个输出说明当前系统的运行级别为 2。而且系统没有之前的运行级别，也就是说在系统上电启动进入预定运行级别之后没有再修改过运行级别。</p>
<p>那么如何修改系统上电之后的默认运行级别呢？</p>
<p>在 Upstart 系统中，需要修改/etc/init/rc-sysinti.conf 中的 DEFAULT_RUNLEVEL 这个参数，以便修改默认启动运行级别。这一点和 sysvinit 的习惯有所不同，大家需要格外留意。</p>
<p>还有一些随 UpStart 发布的小工具，用来帮助开发 UpStart 或者诊断 UpStart 的问题。比如 init-checkconf 和 upstart-monitor</p>
<p>还可以使用 initctl 的 emit 命令从命令行发送一个事件。<br><code>#initctl emit &lt;event&gt;</code><br>这一般是用于 UpStart 本身的排错。</p>
<h3 id="Upstart-小结"><a href="#Upstart-小结" class="headerlink" title="Upstart 小结"></a>Upstart 小结</h3><p>可以看到，UpStart 的设计比 SysVInit 更加先进。多数 Linux 发行版上已经不再使用 SysVInit，一部分发行版采用了 UpStart，比如 Ubuntu；而另外一些比如 Fedora，采用了一种被称为 systemd 的 init 系统。Systemd 出现的比 UpStart 更晚，但发展迅速，虽然 UpStart 也还在积极开发并被越来越多地应用，但 systemd 似乎发展更快，我将在下一篇文章中再介绍 systemd。</p>
<hr>
<h3 id="Systemd-的简介和特点"><a href="#Systemd-的简介和特点" class="headerlink" title="Systemd 的简介和特点"></a>Systemd 的简介和特点</h3><p>Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。systemd 和 ubuntu 的 upstart 是竞争对手，预计会取代 UpStart，实际上在作者写作本文时，已经有消息称 Ubuntu 也将采用 systemd 作为其标准的系统初始化系统。</p>
<p>Systemd 的很多概念来源于苹果 Mac OS 操作系统上的 launchd，不过 launchd 专用于苹果系统，因此长期未能获得应有的广泛关注。Systemd 借鉴了很多 launchd 的思想，它的重要特性如下：</p>
<h4 id="同-SysVinit-和-LSB-init-scripts-兼容"><a href="#同-SysVinit-和-LSB-init-scripts-兼容" class="headerlink" title="同 SysVinit 和 LSB init scripts 兼容"></a>同 SysVinit 和 LSB init scripts 兼容</h4><p>Systemd 是一个”新来的”，Linux 上的很多应用程序并没有来得及为它做相应的改变。和 UpStart 一样，systemd 引入了新的配置方式，对应用程序的开发也有一些新的要求。如果 systemd 想替代目前正在运行的初始化系统，就必须和现有程序兼容。任何一个 Linux 发行版都很难为了采用 systemd 而在短时间内将所有的服务代码都修改一遍。</p>
<p>Systemd 提供了和 Sysvinit 以及 LSB initscripts 兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向 systemd 迁移的成本，使得 systemd 替换现有初始化系统成为可能。</p>
<h4 id="更快的启动速度"><a href="#更快的启动速度" class="headerlink" title="更快的启动速度"></a>更快的启动速度</h4><p>Systemd 提供了比 UpStart 更激进的并行启动能力，采用了 socket / D-Bus activation 等技术启动服务。一个显而易见的结果就是：更快的启动速度。</p>
<p>为了减少系统启动时间，systemd 的目标是：</p>
<ul>
<li><p>尽可能启动更少的进程</p>
</li>
<li><p>尽可能将更多进程并行启动</p>
</li>
</ul>
<p>同样地，UpStart 也试图实现这两个目标。UpStart 采用事件驱动机制，服务可以暂不启动，当需要的时候才通过事件触发其启动，这符合第一个设计目标；此外，不相干的服务可以并行启动，这也实现了第二个目标。</p>
<p>下面的图形演示了 UpStart 相对于 SysVInit 在并发启动这个方面的改进：</p>
<p><strong> UpStart 对 SysVinit 的改进 </strong></p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/image003.jpg" alt=""></p>
<p>假设有 7 个不同的启动项目， 比如 JobA、Job B 等等。在 SysVInit 中，每一个启动项目都由一个独立的脚本负责，它们由 sysVinit 顺序地，串行地调用。因此总的启动时间为 T1+T2+T3+T4+T5+T6+T7。其中一些任务有依赖关系，比如 A,B,C,D。</p>
<p>而 Job E 和 F 却和 A,B,C,D 无关。这种情况下，UpStart 能够并发地运行任务{E，F，(A,B,C,D)}，使得总的启动时间减少为 T1+T2+T3。</p>
<p>这无疑增加了系统启动的并行性，从而提高了系统启动速度。但是在 UpStart 中，有依赖关系的服务还是必须先后启动。比如任务 A,B,(C,D)因为存在依赖关系，所以在这个局部，还是串行执行。</p>
<p>让我们例举一些例子， Avahi 服务需要 D-Bus 提供的功能，因此 Avahi 的启动依赖于 D-Bus，UpStart 中，Avahi 必须等到 D-Bus 启动就绪之后才开始启动。类似的，livirtd 和 X11 都需要 HAL 服务先启动，而所有这些服务都需要 syslog 服务记录日志，因此它们都必须等待 syslog 服务先启动起来。然而 httpd 和他们都没有关系，因此 httpd 可以和 Avahi 等服务并发启动。</p>
<p>Systemd 能够更进一步提高并发性，即便对于那些 UpStart 认为存在相互依赖而必须串行的服务，比如 Avahi 和 D-Bus 也可以并发启动。从而实现如下图所示的并发启动过程：</p>
<p><strong> systemd 的并发启动 </strong></p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/image005.jpg" alt=""></p>
<p>所有的任务都同时并发执行，总的启动时间被进一步降低为 T1。</p>
<p>可见 systemd 比 UpStart 更进一步提高了并行启动能力，极大地加速了系统启动时间。</p>
<h4 id="systemd-提供按需启动能力"><a href="#systemd-提供按需启动能力" class="headerlink" title="systemd 提供按需启动能力"></a>systemd 提供按需启动能力</h4><p>当 sysvinit 系统初始化的时候，它会将所有可能用到的后台服务进程全部启动运行。并且系统必须等待所有的服务都启动就绪之后，才允许用户登录。这种做法有两个缺点：首先是启动时间过长；其次是系统资源浪费。</p>
<p>某些服务很可能在很长一段时间内，甚至整个服务器运行期间都没有被使用过。比如 CUPS，打印服务在多数服务器上很少被真正使用到。您可能没有想到，在很多服务器上 SSHD 也是很少被真正访问到的。花费在启动这些服务上的时间是不必要的；同样，花费在这些服务上的系统资源也是一种浪费。</p>
<p>Systemd 可以提供按需启动的能力，只有在某个服务被真正请求的时候才启动它。当该服务结束，systemd 可以关闭它，等待下次需要时再次启动它。</p>
<h4 id="Systemd-采用-Linux-的-Cgroup-特性跟踪和管理进程的生命周期"><a href="#Systemd-采用-Linux-的-Cgroup-特性跟踪和管理进程的生命周期" class="headerlink" title="Systemd 采用 Linux 的 Cgroup 特性跟踪和管理进程的生命周期"></a>Systemd 采用 Linux 的 Cgroup 特性跟踪和管理进程的生命周期</h4><p>init 系统的一个重要职责就是负责跟踪和管理服务进程的生命周期。它不仅可以启动一个服务，也必须也能够停止服务。这看上去没有什么特别的，然而在真正用代码实现的时候，您或许会发现停止服务比一开始想的要困难。</p>
<p>服务进程一般都会作为精灵进程（daemon）在后台运行，为此服务程序有时候会派生(fork)两次。在 UpStart 中，需要在配置文件中正确地配置 expect 小节。这样 UpStart 通过对 fork 系统调用进行计数，从而获知真正的精灵进程的 PID 号。</p>
<p><strong> 找到正确 pid </strong></p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/image007.jpg" alt=""></p>
<p>如果 UpStart 找错了，将 p1作为服务进程的 Pid，那么停止服务的时候，UpStart 会试图杀死 p1进程，而真正的 p1进程则继续执行。换句话说该服务就失去控制了。</p>
<p>还有更加特殊的情况。比如，一个 CGI 程序会派生两次，从而脱离了和 Apache 的父子关系。当 Apache 进程被停止后，该 CGI 程序还在继续运行。而我们希望服务停止后，所有由它所启动的相关进程也被停止。</p>
<p>为了处理这类问题，UpStart 通过 strace 来跟踪 fork、exit 等系统调用，但是这种方法很笨拙，且缺乏可扩展性。systemd 则利用了 Linux 内核的特性即 CGroup 来完成跟踪的任务。当停止服务时，通过查询 CGroup，systemd 可以确保找到所有的相关进程，从而干净地停止服务。</p>
<p>CGroup 已经出现了很久，它主要用来实现系统资源配额管理。CGroup 提供了类似文件系统的接口，使用方便。当进程创建子进程时，子进程会继承父进程的 CGroup。因此无论服务如何启动新的子进程，所有的这些相关进程都会属于同一个 CGroup，systemd 只需要简单地遍历指定的 CGroup 即可正确地找到所有的相关进程，将它们一一停止即可。</p>
<h4 id="启动挂载点和自动挂载的管理"><a href="#启动挂载点和自动挂载的管理" class="headerlink" title="启动挂载点和自动挂载的管理"></a>启动挂载点和自动挂载的管理</h4><p>传统的 Linux 系统中，用户可以用/etc/fstab 文件来维护固定的文件系统挂载点。这些挂载点在系统启动过程中被自动挂载，一旦启动过程结束，这些挂载点就会确保存在。这些挂载点都是对系统运行至关重要 的文件系统，比如 HOME 目录。和 sysvinit 一样，Systemd 管理这些挂载点，以便能够在系统启动时自动挂载它们。Systemd 还兼容/etc/fstab 文件，您可以继续使用该文件管理挂载点。</p>
<p>有时候用户还需要动态挂载点，比如打算访问 DVD 内容时，才临时执行挂载以便访问其中的内容，而不访问光盘时该挂载点被取消(umount)，以便节约资源。传统地，人们依赖 autofs 服务来实现这种功能。</p>
<p>Systemd 内建了自动挂载服务，无需另外安装 autofs 服务，可以直接使用 systemd 提供的自动挂载管理能力来实现 autofs 的功能。</p>
<h4 id="实现事务性依赖关系管理"><a href="#实现事务性依赖关系管理" class="headerlink" title="实现事务性依赖关系管理"></a>实现事务性依赖关系管理</h4><p>系统启动过程是由很多的独立工作共同组成的，这些工作之间可能存在依赖关系，比如挂载一个 NFS 文件系统必须依赖网络能够正常工作。Systemd 虽然能够最大限度地并发执行很多有依赖关系的工作，但是类似”挂载 NFS”和”启动网络”这样的工作还是存在天生的先后依赖关系，无法并发执行。对于这些任务，systemd 维护一个”事务一致性”的概念，保证所有相关的服务都可以正常启动而不会出现互相依赖，以至于死锁的情况。</p>
<h4 id="能够对系统进行快照和恢复"><a href="#能够对系统进行快照和恢复" class="headerlink" title="能够对系统进行快照和恢复"></a>能够对系统进行快照和恢复</h4><p>systemd 支持按需启动，因此系统的运行状态是动态变化的，人们无法准确地知道系统当前运行了哪些服务。Systemd 快照提供了一种将当前系统运行状态保存并恢复的能力。</p>
<p>比如系统当前正运行服务 A 和 B，可以用 systemd 命令行对当前系统运行状况创建快照。然后将进程 A 停止，或者做其他的任意的对系统的改变，比如启动新的进程 C。在这些改变之后，运行 systemd 的快照恢复命令，就可立即将系统恢复到快照时刻的状态，即只有服务 A，B 在运行。一个可能的应用场景是调试：比如服务器出现一些异常，为了调试用户将当前状态保存为快照，然后可以进行任意的操作，比如停止服务等等。等调试结 束，恢复快照即可。</p>
<p>这个快照功能目前在 systemd 中并不完善，似乎开发人员也没有特别关注它，因此有报告指出它还存在一些使用上的问题，使用时尚需慎重。</p>
<h4 id="日志服务"><a href="#日志服务" class="headerlink" title="日志服务"></a>日志服务</h4><p>systemd 自带日志服务 journald，该日志服务的设计初衷是克服现有的 syslog 服务的缺点。比如：</p>
<p>syslog 不安全，消息的内容无法验证。每一个本地进程都可以声称自己是 Apache PID 4711，而 syslog 也就相信并保存到磁盘上。</p>
<p>数据没有严格的格式，非常随意。自动化的日志分析器需要分析人类语言字符串来识别消息。一方面此类分析困难低效；此外日志格式的变化会导致分析代码需要更新甚至重写。</p>
<p>Systemd Journal 用二进制格式保存所有日志信息，用户使用 journalctl 命令来查看日志信息。无需自己编写复杂脆弱的字符串分析处理程序。</p>
<p>Systemd Journal 的优点如下：</p>
<ul>
<li><p>简单性：代码少，依赖少，抽象开销最小。</p>
</li>
<li><p>零维护：日志是除错和监控系统的核心功能，因此它自己不能再产生问题。举例说，自动管理磁盘空间，避免由于日志的不断产生而将磁盘空间耗尽。</p>
</li>
<li><p>移植性：日志 文件应该在所有类型的 Linux 系统上可用，无论它使用的何种 CPU 或者字节序。</p>
</li>
<li><p>性能：添加和浏览 日志 非常快。</p>
</li>
<li><p>最小资源占用：日志 数据文件需要较小。</p>
</li>
<li><p>统一化：各种不同的日志存储技术应该统一起来，将所有的可记录事件保存在同一个数据存储中。所以日志内容的全局上下文都会被保存并且可供日后查询。例如一条 固件记录后通常会跟随一条内核记录，最终还会有一条用户态记录。重要的是当保存到硬盘上时这三者之间的关系不会丢失。Syslog 将不同的信息保存到不同的文件中，分析的时候很难确定哪些条目是相关的。</p>
</li>
<li><p>扩展性：日志的适用范围很广，从嵌入式设备到超级计算机集群都可以满足需求。</p>
</li>
<li><p>安全性：日志 文件是可以验证的，让无法检测的修改不再可能。</p>
</li>
</ul>
<h3 id="Systemd-的基本概念"><a href="#Systemd-的基本概念" class="headerlink" title="Systemd 的基本概念"></a>Systemd 的基本概念</h3><h4 id="单元的概念"><a href="#单元的概念" class="headerlink" title="单元的概念"></a>单元的概念</h4><p>系统初始化需要做的事情非常多。需要启动后台服务，比如启动 SSHD 服务；需要做配置工作，比如挂载文件系统。这个过程中的每一步都被 systemd 抽象为一个配置单元，即 unit。可以认为一个服务是一个配置单元；一个挂载点是一个配置单元；一个交换分区的配置是一个配置单元；等等。systemd 将配置单元归纳为以下一些不同的类型。然而，systemd 正在快速发展，新功能不断增加。所以配置单元类型可能在不久的将来继续增加。</p>
<ul>
<li><p>service ：代表一个后台服务进程，比如 mysqld。这是最常用的一类。</p>
</li>
<li><p>socket ：此类配置单元封装系统和互联网中的一个 套接字 。当下，systemd 支持流式、数据报和连续包的 AF_INET、AF_INET6、AF_UNIX socket 。每一个套接字配置单元都有一个相应的服务配置单元 。相应的服务在第一个”连接”进入套接字时就会启动(例如：nscd.socket 在有新连接后便启动 nscd.service)。</p>
</li>
<li><p>device ：此类配置单元封装一个存在于 Linux 设备树中的设备。每一个使用 udev 规则标记的设备都将会在 systemd 中作为一个设备配置单元出现。</p>
</li>
<li><p>mount ：此类配置单元封装文件系统结构层次中的一个挂载点。Systemd 将对这个挂载点进行监控和管理。比如可以在启动时自动将其挂载；可以在某些条件下自动卸载。Systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。</p>
</li>
<li><p>automount ：此类配置单元封装系统结构层次中的一个自挂载点。每一个自挂载配置单元对应一个挂载配置单元 ，当该自动挂载点被访问时，systemd 执行挂载点中定义的挂载行为。</p>
</li>
<li><p>swap: 和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元来定义系统中的交换分区，可以让这些交换分区在启动时被激活。</p>
</li>
<li><p>target ：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引用其他配置单元而已。这样便可以对配置单元做一个统一的控制。这样就可以实 现大家都已经非常熟悉的运行级别概念。比如想让系统进入图形化模式，需要运行许多服务和配置命令，这些操作都由一个个的配置单元表示，将所有这些配置单元 组合为一个目标(target)，就表示需要将这些配置单元全部执行一遍以便进入目标所代表的系统运行状态。 (例如：multi-user.target 相当于在传统使用 SysV 的系统中运行级别 5)</p>
</li>
<li><p>timer：定时器配置单元用来定时触发用户定义的操作，这类配置单元取代了 atd、crond 等传统的定时服务。</p>
</li>
<li><p>snapshot ：与 target 配置单元相似，快照是一组配置单元。它保存了系统当前的运行状态。</p>
</li>
</ul>
<p>每个配置单元都有一个对应的配置文件，系统管理员的任务就是编写和维护这些不同的配置文件，比如一个 MySQL 服务对应一个 mysql.service 文件。这种配置文件的语法非常简单，用户不需要再编写和维护复杂的系统 5 脚本了。</p>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>虽然 systemd 将大量的启动工作解除了依赖，使得它们可以并发启动。但还是存在有些任务，它们之间存在天生的依赖，不能用”套接字激活”(socket activation)、D-Bus activation 和 autofs 三大方法来解除依赖（三大方法详情见后续描述）。比如：挂载必须等待挂载点在文件系统中被创建；挂载也必须等待相应的物理设备就绪。为了解决这类依赖问 题，systemd 的配置单元之间可以彼此定义依赖关系。</p>
<p>Systemd 用配置单元定义文件中的关键字来描述配置单元之间的依赖关系。比如：unit A 依赖 unit B，可以在 unit B 的定义中用”require A”来表示。这样 systemd 就会保证先启动 A 再启动 B。</p>
<h4 id="Systemd-事务"><a href="#Systemd-事务" class="headerlink" title="Systemd 事务"></a>Systemd 事务</h4><p>Systemd 能保证事务完整性。Systemd 的事务概念和数据库中的有所不同，主要是为了保证多个依赖的配置单元之间没有环形引用。比如 unit A、B、C，假如它们的依赖关系为:</p>
<p><strong> Unit 的循环依赖 </strong></p>
<p><img src="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/image009.jpg" alt=""></p>
<p>存在循环依赖，那么 systemd 将无法启动任意一个服务。此时 systemd 将会尝试解决这个问题，因为配置单元之间的依赖关系有两种：required 是强依赖；want 则是弱依赖，systemd 将去掉 wants 关键字指定的依赖看看是否能打破循环。如果无法修复，systemd 会报错。</p>
<p>Systemd 能够自动检测和修复这类配置错误，极大地减轻了管理员的排错负担。</p>
<h4 id="Target-和运行级别"><a href="#Target-和运行级别" class="headerlink" title="Target 和运行级别"></a>Target 和运行级别</h4><p>systemd 用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其它服务，来创建自己的目标。下表列举了 systemd 下的目标和常见 runlevel 的对应关系：</p>
<p><strong> Sysvinit 运行级别和 systemd 目标的对应表 </strong></p>
<table>
<thead>
<tr>
<th>Sysvinit 运行级别</th>
<th>Systemd 目标</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>runlevel0.target, poweroff.target</td>
<td>关闭系统。</td>
</tr>
<tr>
<td>1, s, single</td>
<td>runlevel1.target, rescue.target</td>
<td>单用户模式。</td>
</tr>
<tr>
<td>2, 4</td>
<td>runlevel2.target, runlevel4.target, multi-user.target</td>
<td>用户定义/域特定运行级别。默认等同于 3。</td>
</tr>
<tr>
<td>3</td>
<td>runlevel3.target, multi-user.target</td>
<td>多用户，非图形化。用户可以通过多个控制台或网络登录。</td>
</tr>
<tr>
<td>5</td>
<td>runlevel5.target, graphical.target</td>
<td>多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td>
</tr>
<tr>
<td>6</td>
<td>runlevel6.target, reboot.target</td>
<td>重启</td>
</tr>
<tr>
<td>emergency</td>
<td>emergency.target</td>
<td>紧急 Shell</td>
</tr>
</tbody>
</table>
<h3 id="Systemd-的并发启动原理"><a href="#Systemd-的并发启动原理" class="headerlink" title="Systemd 的并发启动原理"></a>Systemd 的并发启动原理</h3><p>如前所述，在 Systemd 中，所有的服务都并发启动，比如 Avahi、D-Bus、livirtd、X11、HAL 可以同时启动。乍一看，这似乎有点儿问题，比如 Avahi 需要 syslog 的服务，Avahi 和 syslog 同时启动，假设 Avahi 的启动比较快，所以 syslog 还没有准备好，可是 Avahi 又需要记录日志，这岂不是会出现问题？</p>
<p>Systemd 的开发人员仔细研究了服务之间相互依赖的本质问题，发现所谓依赖可以分为三个具体的类型，而每一个类型实际上都可以通过相应的技术解除依赖关系。</p>
<h4 id="并发启动原理之一：解决-socket-依赖"><a href="#并发启动原理之一：解决-socket-依赖" class="headerlink" title="并发启动原理之一：解决 socket 依赖"></a>并发启动原理之一：解决 socket 依赖</h4><p>绝大多数的服务依赖是套接字依赖。比如服务 A 通过一个套接字端口 S1 提供自己的服务，其他的服务如果需要服务 A，则需要连接 S1。因此如果服务 A 尚未启动，S1 就不存在，其他的服务就会得到启动错误。所以传统地，人们需要先启动服务 A，等待它进入就绪状态，再启动其他需要它的服务。Systemd 认为，只要我们预先把 S1 建立好，那么其他所有的服务就可以同时启动而无需等待服务 A 来创建 S1 了。如果服务 A 尚未启动，那么其他进程向 S1 发送的服务请求实际上会被 Linux 操作系统缓存，其他进程会在这个请求的地方等待。一旦服务 A 启动就绪，就可以立即处理缓存的请求，一切都开始正常运行。</p>
<p>那么服务如何使用由 init 进程创建的套接字呢？</p>
<p>Linux 操作系统有一个特性，当进程调用 fork 或者 exec 创建子进程之后，所有在父进程中被打开的文件句柄 (file descriptor) 都被子进程所继承。套接字也是一种文件句柄，进程 A 可以创建一个套接字，此后当进程 A 调用 exec 启动一个新的子进程时，只要确保该套接字的 close_on_exec 标志位被清空，那么新的子进程就可以继承这个套接字。子进程看到的套接字和父进程创建的套接字是同一个系统套接字，就仿佛这个套接字是子进程自己创建的一 样，没有任何区别。</p>
<p>这个特性以前被一个叫做 inetd 的系统服务所利用。Inetd 进程会负责监控一些常用套接字端口，比如 Telnet，当该端口有连接请求时，inetd 才启动 telnetd 进程，并把有连接的套接字传递给新的 telnetd 进程进行处理。这样，当系统没有 telnet 客户端连接时，就不需要启动 telnetd 进程。Inetd 可以代理很多的网络服务，这样就可以节约很多的系统负载和内存资源，只有当有真正的连接请求时才启动相应服务，并把套接字传递给相应的服务进程。</p>
<p>和 inetd 类似，systemd 是所有其他进程的父进程，它可以先建立所有需要的套接字，然后在调用 exec 的时候将该套接字传递给新的服务进程，而新进程直接使用该套接字进行服务即可。</p>
<h4 id="并发启动原理之二：解决-D-Bus-依赖"><a href="#并发启动原理之二：解决-D-Bus-依赖" class="headerlink" title="并发启动原理之二：解决 D-Bus 依赖"></a>并发启动原理之二：解决 D-Bus 依赖</h4><p>D-Bus 是 desktop-bus 的简称，是一个低延迟、低开销、高可用性的进程间通信机制。它越来越多地用于应用程序之间通信，也用于应用程序和操作系统内核之间的通信。很多现代的服务 进程都使用D-Bus 取代套接字作为进程间通信机制，对外提供服务。比如简化 Linux 网络配置的 NetworkManager 服务就使用 D-Bus 和其他的应用程序或者服务进行交互：邮件客户端软件 evolution 可以通过 D-Bus 从 NetworkManager 服务获取网络状态的改变，以便做出相应的处理。</p>
<p>D-Bus 支持所谓”bus activation”功能。如果服务 A 需要使用服务 B 的 D-Bus 服务，而服务 B 并没有运行，则 D-Bus 可以在服务 A 请求服务 B 的 D-Bus 时自动启动服务 B。而服务 A 发出的请求会被 D-Bus 缓存，服务 A 会等待服务 B 启动就绪。利用这个特性，依赖 D-Bus 的服务就可以实现并行启动。</p>
<h4 id="并发启动原理之三：解决文件系统依赖"><a href="#并发启动原理之三：解决文件系统依赖" class="headerlink" title="并发启动原理之三：解决文件系统依赖"></a>并发启动原理之三：解决文件系统依赖</h4><p>系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工 作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。但是 systemd 发现这种依赖也是可以避免的。</p>
<p>Systemd 参考了 autofs 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。autofs 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 automounter 模块的支持而实现的。比如一个 open()系统调用作用在”/misc/cd/file1”的时候，/misc/cd 尚未执行挂载操作，此时 open()调用被挂起等待，Linux 内核通知 autofs，autofs 执行挂载。这时候，控制权返回给 open()系统调用，并正常打开文件。</p>
<p>Systemd 集成了 autofs 的实现，对于系统中的挂载点，比如/home，当系统启动的时候，systemd 为其创建一个临时的自动挂载点。在这个时刻/home 真正的挂载设备尚未启动好，真正的挂载操作还没有执行，文件系统检测也还没有完成。可是那些依赖该目录的进程已经可以并发启动，他们的 open()操作被内建在 systemd 中的 autofs 捕获，将该  open()调用挂起（可中断睡眠状态）。然后等待真正的挂载操作完成，文件系统检测也完成后，systemd 将该自动挂载点替换为真正的挂载点，并让 open()调用返回。由此，实现了那些依赖于文件系统的服务和文件系统本身同时并发启动。</p>
<p>当然对于”/“根目录的依赖实际上一定还是要串行执行，因为 systemd 自己也存放在/之下，必须等待系统根目录挂载检查好。</p>
<p>不过对于类似/home 等挂载点，这种并发可以提高系统的启动速度，尤其是当/home 是远程的 NFS 节点，或者是加密盘等，需要耗费较长的时间才可以准备就绪的情况下，因为并发启动，这段时间内，系统并不是完全无事可做，而是可以利用这段空余时间做更多 的启动进程的事情，总的来说就缩短了系统启动时间。</p>
<h3 id="Systemd-的使用"><a href="#Systemd-的使用" class="headerlink" title="Systemd 的使用"></a>Systemd 的使用</h3><p>下面针对技术人员的不同角色来简单地介绍一下 systemd 的使用。本文只打算给出简单的描述，让您对 systemd 的使用有一个大概的理解。具体的细节内容太多，即无法在一篇短文内写全，本人也没有那么强大的能力。还需要读者自己去进一步查阅 systemd 的文档。</p>
<h4 id="系统软件开发人员"><a href="#系统软件开发人员" class="headerlink" title="系统软件开发人员"></a>系统软件开发人员</h4><p>开发人员需要了解 systemd 的更多细节。比如您打算开发一个新的系统服务，就必须了解如何让这个服务能够被 systemd 管理。这需要您注意以下这些要点：</p>
<ul>
<li><p>后台服务进程代码不需要执行两次派生来实现后台精灵进程，只需要实现服务本身的主循环即可。</p>
</li>
<li><p>不要调用 setsid()，交给 systemd 处理</p>
</li>
<li><p>不再需要维护 pid 文件。</p>
</li>
<li><p>Systemd 提供了日志功能，服务进程只需要输出到 stderr 即可，无需使用 syslog。</p>
</li>
<li><p>处理信号 SIGTERM，这个信号的唯一正确作用就是停止当前服务，不要做其他的事情。</p>
</li>
<li><p>SIGHUP 信号的作用是重启服务。</p>
</li>
<li><p>需要套接字的服务，不要自己创建套接字，让 systemd 传入套接字。</p>
</li>
<li><p>使用 sd_notify()函数通知 systemd 服务自己的状态改变。一般地，当服务初始化结束，进入服务就绪状态时，可以调用它。</p>
</li>
</ul>
<p><strong> Unit 文件的编写 </strong></p>
<p>对于开发者来说，工作量最大的部分应该是编写配置单元文件，定义所需要的单元。</p>
<p>举例来说，开发人员开发了一个新的服务程序，比如 httpd，就需要为其编写一个配置单元文件以便该服务可以被 systemd 管理，类似 UpStart 的工作配置文件。在该文件中定义服务启动的命令行语法，以及和其他服务的依赖关系等。</p>
<p>此外我们之前已经了解到，systemd 的功能繁多，不仅用来管理服务，还可以管理挂载点，定义定时任务等。这些工作都是由编辑相应的配置单元文件完成的。我在这里给出几个配置单元文件的例子。</p>
<p>下面是 SSH 服务的配置单元文件，服务配置单元文件以.service 为文件名后缀。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat /etc/system/system/sshd.service</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=OpenSSH server daemon</span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=/etc/sysconfig/sshd</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/sbin/sshd-keygen</span><br><span class="line"><span class="attr">ExecStart</span>=/usrsbin/sshd –D <span class="variable">$OPTIONS</span></span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill –HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">42</span>s</span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>文件分为三个小节。第一个是[Unit]部分，这里仅仅有一个 描述信息。第二部分是 Service 定义，其中，ExecStartPre 定义启动服务之前应该运行的命令；ExecStart 定义启动服务的具体命令行语法。第三部分是[Install]，WangtedBy 表明这个服务是在多用户模式下所需要的。</p>
<p>那我们就来看下 multi-user.target 吧：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#cat</span> multi-user<span class="selector-class">.target</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man<span class="selector-class">.systemd</span><span class="selector-class">.special</span>(<span class="number">7</span>)</span><br><span class="line">Requires=basic<span class="selector-class">.target</span></span><br><span class="line">Conflicts=rescue<span class="selector-class">.service</span> rescure<span class="selector-class">.target</span></span><br><span class="line">After=basic<span class="selector-class">.target</span> rescue<span class="selector-class">.service</span> rescue<span class="selector-class">.target</span></span><br><span class="line">AllowIsolate=yes</span><br><span class="line">[Install]</span><br><span class="line">Alias=default.target</span><br></pre></td></tr></table></figure></p>
<p>第一部分中的 Requires 定义表明 multi-user.target 启动的时候 basic.target 也必须被启动；另外 basic.target 停止的时候，multi-user.target 也必须停止。如果您接着查看 basic.target 文件，会发现它又指定了 sysinit.target 等其他的单元必须随之启动。同样 sysinit.target 也会包含其他的单元。采用这样的层层链接的结构，最终所有需要支持多用户模式的组件服务都会被初始化启动好。</p>
<p>在[Install]小节中有 Alias 定义，即定义本单元的别名，这样在运行 systemctl 的时候就可以使用这个别名来引用本单元。这里的别名是 default.target，比 multi-user.target 要简单一些。。。</p>
<p>此外在/etc/systemd/system 目录下还可以看到诸如*.wants 的目录，放在该目录下的配置单元文件等同于在[Unit]小节中的 wants 关键字，即本单元启动时，还需要启动这些单元。比如您可以简单地把您自己写的 foo.service 文件放入 multi-user.target.wants 目录下，这样每次都会被默认启动了。</p>
<p>最后，让我们来看看 sys-kernel-debug.mout 文件，这个文件定义了一个文件挂载点：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat sys-kernel-debug.mount</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Debug File Syste</span><br><span class="line"><span class="attr">DefaultDependencies</span>=<span class="literal">no</span></span><br><span class="line"><span class="attr">ConditionPathExists</span>=/sys/kernel/debug</span><br><span class="line"><span class="attr">Before</span>=sysinit.target</span><br><span class="line"><span class="section">[Mount]</span></span><br><span class="line"><span class="attr">What</span>=debugfs</span><br><span class="line"><span class="attr">Where</span>=/sys/kernel/debug</span><br><span class="line"><span class="attr">Type</span>=debugfs</span><br></pre></td></tr></table></figure></p>
<p>这个配置单元文件定义了一个挂载点。挂载配置单元文件有一个[Mount]配置小节，里面配置了 What，Where 和 Type 三个数据项。这都是挂载命令所必须的，例子中的配置等同于下面这个挂载命令：</p>
<p><code>mount –t debugfs /sys/kernel/debug debugfs</code></p>
<p>配置单元文件的编写需要很多的学习，必须参考 systemd 附带的 man 等文档进行深入学习。希望通过上面几个小例子，大家已经了解配置单元文件的作用和一般写法了。</p>
<h4 id="系统管理员"><a href="#系统管理员" class="headerlink" title="系统管理员"></a>系统管理员</h4><p>systemd 的主要命令行工具是 systemctl。</p>
<p>多数管理员应该都已经非常熟悉系统服务和 init 系统的管理，比如 service、chkconfig 以及 telinit 命令的使用。systemd 也完成同样的管理任务，只是命令工具 systemctl 的语法有所不同而已，因此用表格来对比 systemctl 和传统的系统管理命令会非常清晰。</p>
<p><strong> Systemd 命令和 sysvinit 命令的对照表 </strong></p>
<table>
<thead>
<tr>
<th>Sysvinit 命令</th>
<th>Systemd 命令</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>service foo start</td>
<td>systemctl start foo.service</td>
<td>用来启动一个服务 (并不会重启现有的)</td>
</tr>
<tr>
<td>service foo stop</td>
<td>systemctl stop foo.service</td>
<td>用来停止一个服务 (并不会重启现有的)。</td>
</tr>
<tr>
<td>service foo restart</td>
<td>systemctl restart foo.service</td>
<td>用来停止并启动一个服务。</td>
</tr>
<tr>
<td>service foo reload</td>
<td>systemctl reload foo.service</td>
<td>当支持时，重新装载配置文件而不中断等待操作。</td>
</tr>
<tr>
<td>service foo condrestart</td>
<td>systemctl condrestart foo.service</td>
<td>如果服务正在运行那么重启它。</td>
</tr>
<tr>
<td>service foo status</td>
<td>systemctl status foo.service</td>
<td>汇报服务是否正在运行。</td>
</tr>
<tr>
<td>ls /etc/rc.d/init.d/</td>
<td>systemctl list-unit-files –type=service</td>
<td>用来列出可以启动或停止的服务列表。</td>
</tr>
<tr>
<td>chkconfig foo on</td>
<td>systemctl enable foo.service</td>
<td>在下次启动时或满足其他触发条件时设置服务为启用</td>
</tr>
<tr>
<td>chkconfig foo off</td>
<td>systemctl disable foo.service</td>
<td>在下次启动时或满足其他触发条件时设置服务为禁用</td>
</tr>
<tr>
<td>chkconfig foo</td>
<td>systemctl is-enabled foo.service</td>
<td>用来检查一个服务在当前环境下被配置为启用还是禁用。</td>
</tr>
<tr>
<td>chkconfig –list</td>
<td>systemctl list-unit-files –type=service</td>
<td>输出在各个运行级别下服务的启用和禁用情况</td>
</tr>
<tr>
<td>chkconfig foo –list</td>
<td>ls /etc/systemd/system/*.wants/foo.service</td>
<td>用来列出该服务在哪些运行级别下启用和禁用。</td>
</tr>
<tr>
<td>chkconfig foo –add</td>
<td>systemctl daemon-reload</td>
<td>当您创建新服务文件或者变更设置时使用。</td>
</tr>
<tr>
<td>telinit 3</td>
<td>systemctl isolate multi-user.target (OR systemctl isolate runlevel3.target OR telinit 3)</td>
<td>改变至多用户运行级别。</td>
</tr>
</tbody>
</table>
<p>表中列出的常见用法，系统管理员还需要了解其他一些系统配置和管理任务的改变。</p>
<p>首先我们了解 systemd 如何处理电源管理，命令如下表所示：</p>
<p><strong> systemd 电源管理命令 </strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>systemctl reboot</td>
<td>重启机器</td>
</tr>
<tr>
<td>systemctl poweroff</td>
<td>关机</td>
</tr>
<tr>
<td>systemctl suspend</td>
<td>待机</td>
</tr>
<tr>
<td>systemctl hibernate</td>
<td>休眠</td>
</tr>
<tr>
<td>systemctl hybrid-sleep    混合休眠模式（同时休眠到硬盘并待机）</td>
</tr>
</tbody>
</table>
<p>关机不是每个登录用户在任何情况下都可以执行的，一般只有管理员才可以关机。正常情况下系统 不应该允许 SSH 远程登录的用户执行关机命令。否则其他用户正在工作，一个用户把系统关了就不好了。为了解决这个问题，传统的 Linux 系统使用 ConsoleKit 跟踪用户登录情况，并决定是否赋予其关机的权限。现在 ConsoleKit 已经被 systemd 的 logind 所替代。</p>
<p>logind 不是 pid-1 的 init 进程。它的作用和 UpStart 的 session init 类似，但功能要丰富很多，它能够管理几乎所有用户会话(session)相关的事情。logind 不仅是 ConsoleKit 的替代，它可以：</p>
<ul>
<li><p>维护，跟踪会话和用户登录情况。如上所述，为了决定关机命令是否可行，系统需要了解当前用户登录情况，如果用户从 SSH 登录，不允许其执行关机命令；如果普通用户从本地登录，且该用户是系统中的唯一会话，则允许其执行关机命令；这些判断都需要 logind 维护所有的用户会话和登录情况。</p>
</li>
<li><p>Logind 也负责统计用户会话是否长时间没有操作，可以执行休眠/关机等相应操作。</p>
</li>
<li><p>为用户会话的所有进程创建 CGroup。这不仅方便统计所有用户会话的相关进程，也可以实现会话级别的系统资源控制。</p>
</li>
<li><p>负责电源管理的组合键处理，比如用户按下电源键，将系统切换至睡眠状态。</p>
</li>
<li><p>多席位(multi-seat) 管理。如今的电脑，即便一台笔记本电脑，也完全可以提供多人同时使用的计算能力。多席位就是一台电脑主机管理多个外设，比如两个屏幕和两个鼠标/键盘。席 位一使用屏幕 1 和键盘 1；席位二使用屏幕 2 和键盘 2，但他们都共享一台主机。用户会话可以自由在多个席位之间切换。或者当插入新的键盘，屏幕等物理外设时，自动启动 gdm 用户登录界面等。所有这些都是多席位管理的内容。ConsoleKit 始终没有实现这个功能，systemd 的 logind 能够支持多席位。</p>
</li>
</ul>
<p>以上描述的这些管理功能仅仅是 systemd 的部分功能，除此之外，systemd 还负责系统其他的管理配置，比如配置网络，Locale 管理，管理系统内核模块加载等，完整地描述它们已经超出了本人的能力。</p>
<h3 id="systemd-小结"><a href="#systemd-小结" class="headerlink" title="systemd 小结"></a>systemd 小结</h3><p>作为系统初始化系统，systemd 的最大特点有两个：</p>
<ul>
<li><p>令人惊奇的激进的并发启动能力，极大地提高了系统启动速度；</p>
</li>
<li><p>用 CGroup 统计跟踪子进程，干净可靠。</p>
</li>
</ul>
<p>此外，和其前任不同的地方在于，systemd 已经不仅仅是一个初始化系统了。</p>
<p>Systemd 出色地替代了 sysvinit 的所有功能，但它并未就此自满。因为 init 进程是系统所有进程的父进程这样的特殊性，systemd 非常适合提供曾经由其他服务提供的功能，比如定时任务 (以前由 crond 完成) ；会话管理 (以前由 ConsoleKit/PolKit 等管理) 。仅仅从本文皮毛一样的介绍来看，Systemd 已经管得很多了，可它还在不断发展。它将逐渐成为一个多功能的系统环境，能够处理非常多的系统管理任务，有人甚至将它看作一个操作系统。</p>
<p>好 的一点是，这非常有助于标准化 Linux 的管理！从前，不同的 Linux 发行版各行其事，使用不同方法管理系统，从来也不会互相妥协。比如如何将系统进入休眠状态，不同的系统有不同的解决方案，即便是同一个 Linux 系统，也存在不同的方法，比如一个有趣的讨论：如何让 ubuntu 系统休眠， 可以使用底层的/sys/power/state 接口，也可以使用诸如 pm-utility 等高层接口。存在这么多种不同的方法做一件事情对像我这样的普通用户而言可不是件有趣的事情。systemd 提供统一的电源管理命令接口，这件事情的意义就类似全世界的人都说统一的语言，我们再也不需要学习外语了，多么美好！</p>
<p>如果所有的 Linux 发行版都采纳了 systemd，那么系统管理任务便可以很大程度上实现标准化。此外 systemd 有个很棒的承诺：接口保持稳定，不会再轻易改动。对于软件开发人员来说，这是多么体贴又让人感动的承诺啊！</p>
<hr>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>文章从古老却简明稳定的 sysvinit 说起，接着简要描述了 UpStart 带来的清新改变，最后看到了充满野心和活力的新生代 systemd 系统逐渐统治 Linux 的各个版本。就好像在看我们这个世界，一代人老去，新的一代带着横扫一切的气概登上舞台，还没有喊出他们最有力的口号，更猛的一代已经把聚光灯和所有的目 光带走。Systemd 之后也许还有更新的 init 系统出现吧，让我们继续期待。。。</p>
<p>整理文档链接：</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[罪己]]></title>
      <url>http://qiankun.space/2016/05/01/thinking-in-international-labour-day/</url>
      <content type="html"><![CDATA[<p>严重的拖延症患者终于想起来五一创建的“罪己”文档还没有写，趁着罪过还不是特别深重赶紧过来“赎罪”。</p>
<p>我时常反省自己，总怕身上的毛病太多引来别人的耻笑。一个人生活在外，如果真发生什么当局者迷的事情，连一个提点的人都没有，岂不是天天像小丑一样暴露在大庭广众之下。脸皮没那么厚，又怕自己受伤害，所以只好选择在孤单的日子里多看看自己。</p>
<blockquote>
<p>“君子博学而日参省乎己，则知明而行无过矣”</p>
</blockquote>
<p>这句话出自于《荀子》的首篇《劝学》，其意义可想而知。上学的时候理解这句话就单纯地以为两个条件独立的对应着两个结果，比如“博学”的结果是“知明”、“省乎己”的结果是“无过矣”。不过自己根本没有按照胡适先生“做学问要在不疑处犹疑”的要求，甚至于有疑处也不疑，只是大致了解全文意思然后粗暴地填到脑海中去应付考试了。现在想想古人真是大智慧啊，只怪自己太傻太天真。</p>
<p>“博学”和“省乎己”是相辅相成缺一不可的。如今的社会节奏比较快，更多的人将重点放在了“博学”上面，依靠“博学”可以很直接地获取被这个浮躁社会高看的“利益”，很少有人肯花时间去审视自己。当大家都不去解读自己的内心，而是将目光投射到周围人的身上，整个社会就会呈现出一种你追我赶末日狂奔的景象，哪怕自己跑掉了身上的衣衫也来不及去整理，更有甚者为了自己能够在这条道路上跑得更快甚至脱掉衣衫裸奔于世而毫无羞耻。某某博士论文剽窃、某某机构骗取国家科研经费等等屡见报端，当这些“博学”之流干下这等龌龊之事成为一种社会常态后，我时常有一种国之大厦将倾的担忧。阿列克谢耶维奇在她的《切尔诺贝利的回忆》中描述一位曾在“二战”期间的德国纳粹集中营中遭受过非人折磨的幸存者见到的情境：毒气室由学有专长的工程师建造；儿童被学识渊博的医生毒死；幼儿被训练有素的护士杀害；妇女和婴儿被受到高中或大学教育的士兵枪杀。“流氓不可怕，就怕流氓有文化”，不反省自我肆无忌惮地放纵内心换来的不一定是自由，也可能是可怕的杀戮和伤害。我有自知之明没有把自己归类到“博学”的一类，可是“省乎己”却同样为自己带来困扰。没有“博学”的支撑，“省乎己”变的单薄，即使自己发现了毛病也没有能力去修正，从而陷入了郁郁寡欢的无知之流。</p>
<p>多读书多看报，开阔自己的眼界，放宽自己的心胸。向“博学”靠近，不断地砥砺自身，变成更好的自己！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[shell脚本调用的三种不同方式]]></title>
      <url>http://qiankun.space/2016/04/28/the-method-called-shell-script/</url>
      <content type="html"><![CDATA[<p>bash的命令分为两类：外部命令和内部命令。外部命令是通过系统调用或独立的程序实现的，如sed、awk等；内部命令是由特殊的文件格式（.def）所实现，如cd、history、exec等。shell脚本调用有三种不同方法：<code>fork</code>, <code>exec</code>, <code>source</code>。其中fork是linux的系统调用，用来创建子进程。exec和source都属于bash内部命令（builtins commands）。</p>
<ul>
<li><p><strong>fork</strong> (/directory/script.sh)：在子命令执行完后再执行父级命令，<strong>子级的环境变量不会影响到父级</strong>。</p>
<ul>
<li><p>fork是最常用的，就是直接在脚本里面用/directory/script.sh来调用script.sh这个脚本。运行的时候开一个sub-shell执行调用的脚本，sub-shell执行的时候， parent-shell还在。sub-shell执行完毕后返回parent-shell。 sub-shell从parent-shell继承环境变量，但是sub-shell中的环境变量不会带回parent-shell。</p>
</li>
<li><p>子进程是父进程(parent process)的一个副本，从父进程那里获得一定的资源分配以及继承父进程的环境。子进程与父进程唯一不同的地方在于pid（process id）。</p>
</li>
</ul>
</li>
<li><p><strong>exec</strong>(exec /directory/script.sh)：<strong> 执行子级的命令后，不再执行父级命令</strong>。</p>
<ul>
<li><p>exec命令在执行时会把当前的shell process关闭，然后换到后面的命令继续执行。</p>
</li>
<li><p>exec与fork不同，不需要新开一个sub-shell来执行被调用的脚本。被调用的脚本与父脚本在同一个shell内执行。但是使用exec调用一个新脚本以后，父脚本中exec行之后的内容就不会再执行了。这是exec和source的区别。</p>
</li>
</ul>
</li>
<li><p><strong>source</strong>(source /directory/script.sh)：<strong> 执行子级命令后继续执行父级命令，同时子级设置的环境变量会影响到父级的环境变量</strong>。</p>
<ul>
<li><p>source命令即点(.)命令。</p>
</li>
<li><p>与fork的区别是不新开一个sub-shell来执行被调用的脚本，而是在同一个shell中执行。所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中得到和使用。</p>
</li>
</ul>
</li>
</ul>
<p>可以通过下面这两个脚本来体会三种调用方式的不同:</p>
<p>1.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">A=B</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh before exec/source/fork:$$"</span></span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">exec</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using exec…"</span></span><br><span class="line">                <span class="built_in">exec</span> ./2.sh ;;</span><br><span class="line">        <span class="built_in">source</span>)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using source…"</span></span><br><span class="line">                . ./2.sh ;;</span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"using fork by default…"</span></span><br><span class="line">                ./2.sh ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 1.sh after exec/source/fork:$$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>2.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PID for 2.sh: $$"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh get \$A=<span class="variable">$A</span> from 1.sh"</span></span><br><span class="line">A=C</span><br><span class="line"><span class="built_in">export</span> A</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2.sh: \$A is <span class="variable">$A</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>执行情况：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="number">1</span><span class="selector-class">.sh</span></span><br><span class="line">PID <span class="keyword">for</span> <span class="number">1</span><span class="selector-class">.sh</span> before exec/source/fork:<span class="number">5845364</span></span><br><span class="line"><span class="number">1</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is B</span><br><span class="line">using fork by default…</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">2</span><span class="selector-class">.sh</span>: <span class="number">5242940</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span> get <span class="variable">$A</span>=B from <span class="number">1</span><span class="selector-class">.sh</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is C</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">1</span><span class="selector-class">.sh</span> after exec/source/fork:<span class="number">5845364</span></span><br><span class="line"><span class="number">1</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is B</span><br><span class="line"></span><br><span class="line">$ ./<span class="number">1</span><span class="selector-class">.sh</span> exec</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">1</span><span class="selector-class">.sh</span> before exec/source/fork:<span class="number">5562668</span></span><br><span class="line"><span class="number">1</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is B</span><br><span class="line">using exec…</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">2</span><span class="selector-class">.sh</span>: <span class="number">5562668</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span> get <span class="variable">$A</span>=B from <span class="number">1</span><span class="selector-class">.sh</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is C</span><br><span class="line"></span><br><span class="line">$ ./<span class="number">1</span><span class="selector-class">.sh</span> source</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">1</span><span class="selector-class">.sh</span> before exec/source/fork:<span class="number">5156894</span></span><br><span class="line"><span class="number">1</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is B</span><br><span class="line">using source…</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">2</span><span class="selector-class">.sh</span>: <span class="number">5156894</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span> get <span class="variable">$A</span>=B from <span class="number">1</span><span class="selector-class">.sh</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is C</span><br><span class="line">PID <span class="keyword">for</span> <span class="number">1</span><span class="selector-class">.sh</span> after exec/source/fork:<span class="number">5156894</span></span><br><span class="line"><span class="number">1</span><span class="selector-class">.sh</span>: <span class="variable">$A</span> is C</span><br></pre></td></tr></table></figure></p>
<p><strong>其他</strong><br>系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p>
<p>整理本文参考链接：<br><a href="http://mindream.wang.blog.163.com/blog/static/2325122220084624318692/" target="_blank" rel="external">http://mindream.wang.blog.163.com/blog/static/2325122220084624318692/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[咕咚来了]]></title>
      <url>http://qiankun.space/2016/04/28/a-short-story-before-writing/</url>
      <content type="html"><![CDATA[<p>就像 <code>helloworld</code> 作为所有编程语言的起始阶段占据着无法改变的地位一样，这个小故事也是我开始写些东西前必不可少的部分。</p>
<blockquote>
<p>湖边有一棵树，树上结满了木瓜。一个木瓜熟了，从树上掉进湖里，咕咚一声，溅起了白色的水花。</p>
<p>兔子听见吓坏了，拔腿就跑，边跑边叫：“快逃哇，咕咚来了！”</p>
<p>猴子听见了，也跟着跑，边跑边叫：“大家快逃哇，咕咚来了！”</p>
<p>这下子可热闹了。动物们全跟着跑起来，边跑边喊：“快逃命啊，咕咚来了！”</p>
<p>大象走来了，拦住了大伙儿：“咕咚在哪儿，你们看见了吗？”</p>
<p>“没看见，是兔子说的！”</p>
<p>大象追问兔子：“你看见咕咚了？”</p>
<p>兔子摇摇头说：“没有，我是在湖边听见的。”</p>
<p>大家悄悄来到湖边，正巧一个木瓜又落到了湖里。咕咚一声，溅起了白色的水花。</p>
<p>大伙儿你看看我，我看看你，都哈哈地笑了！</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
